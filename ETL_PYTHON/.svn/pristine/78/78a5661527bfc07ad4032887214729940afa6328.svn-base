import gc
import logging
import os
from datetime import datetime

from xinxiang.util import my_duck, my_oracle, my_date, cons_error_code, my_postgres, my_file
from xinxiang import config


def create_temp_table(duck_db):
    table_type = ""
    if not config.g_debug_mode:
        table_type = 'TEMP'
    '''
    这里在内存中创建使用到的临时表
    '''
    sql = """
    create {table_type} table APS_TMP_ETL_FLOW_BACKUPEQP
    (
        eqp_g     VARCHAR(64),
        productid VARCHAR(64),
        openo     VARCHAR(64),
        routeid   VARCHAR(64),
        recipe    VARCHAR(64)
    )
    """.format(table_type=table_type)
    duck_db.sql(sql)
    sql = """
    create {table_type} table APS_TMP_ETL_FLOW_SUB_BACKUPEQP
    (
        prod_id    VARCHAR(64),
        ope_no     VARCHAR(64),
        toolg_id   VARCHAR(64),
        plan_id    VARCHAR(64),
        backup_eqp VARCHAR(512)
    )
    """.format(table_type=table_type)
    duck_db.sql(sql)
    sql = """
    create {table_type} table APS_TMP_ETL_FLOW_MAIN
    (
        prod_id       VARCHAR(64),
        plan_no       VARCHAR(64),
        plan_id       VARCHAR(64),
        step_id       VARCHAR(64),
        layer         VARCHAR(64),
        stage         VARCHAR(64),
        toolg_id      VARCHAR(64),
        recipe        VARCHAR(64),
        reticle_group VARCHAR(64),
        step_type     VARCHAR(64),
        toolg_type    VARCHAR(64),
        ope_no        VARCHAR(64),
        capability    VARCHAR(512),
        sgs_flag      VARCHAR(64),
        prodg_id      VARCHAR(64),
        prodg_tech    VARCHAR(64),
        process_time  VARCHAR(64),
        cycle_time    VARCHAR(64),
        sgs_group     VARCHAR(64),
        ope_seq       VARCHAR(64)
    )
    """.format(table_type=table_type)
    duck_db.sql(sql)

    sql = """
    create {table_type} table APS_TMP_ETL_FLOW_RWK_SUB
    (
        prod_id       VARCHAR(64),
        plan_no       VARCHAR(64),
        plan_id       VARCHAR(64),
        step_id       VARCHAR(64),
        layer         VARCHAR(64),
        stage         VARCHAR(64),
        toolg_id      VARCHAR(64),
        recipe        VARCHAR(64),
        reticle_group VARCHAR(64),
        step_type     VARCHAR(64),
        toolg_type    VARCHAR(64),
        ope_no        VARCHAR(64),
        capability    VARCHAR(512),
        sgs_flag      VARCHAR(64),
        prodg_id      VARCHAR(64),
        prodg_tech    VARCHAR(64),
        process_time  VARCHAR(64),
        cycle_time    VARCHAR(64),
        sgs_group     VARCHAR(64),
        ope_seq       VARCHAR(64)
    )
    """.format(table_type=table_type)
    duck_db.sql(sql)

    sql = """
     create {table_type} table APS_TMP_ETL_FLOW
     (
        prod_id       VARCHAR(64),
        plan_no       VARCHAR(64),
        plan_id       VARCHAR(64),
        step_id       VARCHAR(64),
        layer         VARCHAR(64),
        stage         VARCHAR(64),
        toolg_id      VARCHAR(64),
        recipe        VARCHAR(64),
        reticle_group VARCHAR(64),
        step_type     VARCHAR(64),
        toolg_type    VARCHAR(64),
        ope_no        VARCHAR(64),
        capability    VARCHAR(512),
        sgs_flag      VARCHAR(64),
        prodg_id      VARCHAR(64),
        prodg_tech    VARCHAR(64),
        process_time  VARCHAR(64),
        cycle_time    VARCHAR(64),
        sgs_group     VARCHAR(64)
     )
     """.format(table_type=table_type)
    duck_db.sql(sql)

    sql = """
     create {table_type} table APS_TMP_ETL_FLOW_RECIPE
     (
        lcrecipe_id VARCHAR(64),
        ope_no      VARCHAR(64),
        prodspec_id VARCHAR(64),
        mnpd_id     VARCHAR(64),
        eqp_g       VARCHAR(64)
     )
     """.format(table_type=table_type)
    duck_db.sql(sql)

    sql = """
     create {table_type} table APS_TMP_ETL_FLOW_REAL_RWK_SUB
     (
        prod_id    VARCHAR(64),
        plan_no    VARCHAR(64),
        plan_id    VARCHAR(64),
        step_id    VARCHAR(64),
        ope_no     VARCHAR(64),
        eqp_id     VARCHAR(64),
        recipe     VARCHAR(64),
        step_type  VARCHAR(64),
        toolg_id   VARCHAR(64),
        toolg_type VARCHAR(64)
     )
     """.format(table_type=table_type)
    duck_db.sql(sql)

    sql = """
     create {table_type} table APS_TMP_ETL_FLOW_CHANGESEQ
     (
        prod_id       VARCHAR(64),
        plan_no       VARCHAR(64),
        plan_id       VARCHAR(64),
        step_id       VARCHAR(64),
        layer         VARCHAR(64),
        stage         VARCHAR(64),
        toolg_id      VARCHAR(64),
        recipe        VARCHAR(64),
        reticle_group VARCHAR(64),
        step_type     VARCHAR(64),
        toolg_type    VARCHAR(64),
        ope_no        VARCHAR(64),
        capability    VARCHAR(512),
        sgs_flag      VARCHAR(64),
        prodg_id      VARCHAR(64),
        prodg_tech    VARCHAR(64),
        process_time  VARCHAR(64),
        cycle_time    VARCHAR(64),
        sgs_group     VARCHAR(64),
        ope_seq       VARCHAR(64)
     )
     """.format(table_type=table_type)
    duck_db.sql(sql)

    sql = """
     create {table_type} table APS_TMP_ETL_FLOW_VIEW_FLOW
     (
        mnpd_id           VARCHAR(64) not null,
        mnpd_vs           VARCHAR(64),
        prodg1            VARCHAR(64) not null,
        prodspec_id       VARCHAR(64) not null,
        ope_no            VARCHAR(64) not null,
        ope_seq           VARCHAR(64) not null,
        sche_eqp_g        VARCHAR(64),
        eqp_g             VARCHAR(64),
        inline_ct         VARCHAR(64),
        inline_cyc_acc    VARCHAR(64),
        inline_cyc_remain VARCHAR(64),
        tc                VARCHAR(64),
        update_time       VARCHAR(64),
        std_ct            VARCHAR(64),
        sgs_flag          VARCHAR(64),
        sgs_group         VARCHAR(64),
        sgs_first_op      VARCHAR(64),
        sgs_weight        VARCHAR(64),
        sgs_end_op        VARCHAR(64),
        sgs_loop_group    VARCHAR(64),
        inline_proc_time  VARCHAR(64)
     )
     """.format(table_type=table_type)
    duck_db.sql(sql)

    sql = """
     create {table_type} table APS_TMP_ETL_FLOW_PO_N1
     (
        pos_pdid          VARCHAR(64) not null,
        mainpd_id         VARCHAR(64) not null,
        ope_no            VARCHAR(64) not null,
        ope_seq           VARCHAR(64),
        multi_group       VARCHAR(64),
        multi_target_flag VARCHAR(64)
     )
     """.format(table_type=table_type)
    duck_db.sql(sql)

    sql = """
     create {table_type} table APS_TMP_ETL_FLOW_EQP_LOAD
     (
        eqp_id       VARCHAR(64),
        lcrecipe_id  VARCHAR(64),
        pd_id        VARCHAR(64) not null,
        prodspec_id  VARCHAR(64) not null,
        eqp_g        VARCHAR(64),
        eqp_category VARCHAR(64)
     )
     """.format(table_type=table_type)
    duck_db.sql(sql)

    sql = """
     create {table_type} table APS_TMP_ETL_FLOW_TYPE11_MEDIAN
     (
        cycle_time   VARCHAR(64),
        process_time VARCHAR(64),
        prod_id      VARCHAR(64),
        ope_no       VARCHAR(64),
        toolg_id     VARCHAR(64)
     )
     """.format(table_type=table_type)
    duck_db.sql(sql)

    sql = """
     create {table_type} table APS_TMP_ETL_FLOW_TYPE12_MEDIAN
     (
        cycle_time   VARCHAR(64),
        process_time VARCHAR(64),
        toolg_id     VARCHAR(64)
     )
     """.format(table_type=table_type)
    duck_db.sql(sql)

    sql = """
     create {table_type} table APS_TMP_ETL_FLOW_MASK_GROUP
     (
        prodspec_id VARCHAR(64),
        ope_no      VARCHAR(64),
        mask_group  VARCHAR(64)
     )
     """.format(table_type=table_type)
    duck_db.sql(sql)

    sql = """
     create {table_type} table APS_TMP_ETL_FLOW_PROD_DATA
     (
        prodg_id    VARCHAR(64),
        prodg_tech  VARCHAR(64),
        prodspec_id VARCHAR(64)
     )
     """.format(table_type=table_type)
    duck_db.sql(sql)

    sql = """
    create {table_type} table APS_TMP_ETL_FLOW_TOOL_GROUP
    (
        toolg_type VARCHAR(64),
        eqp_g      VARCHAR(64)
    )
    """.format(table_type=table_type)
    duck_db.sql(sql)
    sql = """
        create {table_type} table APS_TMP_ETL_FLOW_MAIN_RSDATA
        (
            recipe      VARCHAR(64),
            prodspec_id VARCHAR(64),
            mnpd_id     VARCHAR(64),
            ope_no      VARCHAR(64),
            eqp_g       VARCHAR(64),
            ope_seq     VARCHAR(64),
            capability  VARCHAR(4000),
            sgs_flag    VARCHAR(64),
            toolg_type  VARCHAR(64),
            sgs_group   VARCHAR(64),
            ct          VARCHAR(64),
            pt          VARCHAR(64)
        )
        """.format(table_type=table_type)
    duck_db.sql(sql)
    sql = """
        create {table_type} table APS_TMP_ETL_FLOW_REWORK_RSDATA
        (
            prod_id          VARCHAR(64),
            plan_no          VARCHAR(64),
            plan_id          VARCHAR(64),
            step_id          VARCHAR(64),
            layer            VARCHAR(64),
            stage            VARCHAR(64),
            toolg_id         VARCHAR(64),
            recipe           VARCHAR(64),
            reticle_group    VARCHAR(64),
            step_type        VARCHAR(64),
            toolg_type       VARCHAR(64),
            sgs_flag         VARCHAR(64),
            sgs_group        VARCHAR(64),
            ope_no           VARCHAR(64),
            prodg_id         VARCHAR(64),
            prodg_tech       VARCHAR(64),
            inline_ct        VARCHAR(64),
            inline_proc_time VARCHAR(64)
        )
        """.format(table_type=table_type)
    duck_db.sql(sql)
    sql = """
        create {table_type} table APS_TMP_ETL_FLOW_REWORK_BACKUPEQP_RSDATA
        (
            prod_id          VARCHAR(64),
            plan_no          VARCHAR(64),
            plan_id          VARCHAR(64),
            step_id          VARCHAR(64),
            layer            VARCHAR(64),
            stage            VARCHAR(64),
            toolg_id         VARCHAR(64),
            recipe           VARCHAR(64),
            reticle_group    VARCHAR(64),
            step_type        VARCHAR(64),
            toolg_type       VARCHAR(64),
            sgs_flag         VARCHAR(64),
            sgs_group        VARCHAR(64),
            ope_no           VARCHAR(64),
            prodg_id         VARCHAR(64),
            prodg_tech       VARCHAR(64),
            inline_ct        VARCHAR(64),
            inline_proc_time VARCHAR(64),
            backup_eqp       VARCHAR(4000)
        )
        """.format(table_type=table_type)
    duck_db.sql(sql)
    sql = """
        create {table_type} table APS_TMP_ETL_FLOW_MAIN_MASK_RSDATA
        (
            prod_id       VARCHAR(64),
            plan_no       VARCHAR(64),
            plan_id       VARCHAR(64),
            step_id       VARCHAR(64),
            layer         VARCHAR(64),
            stage         VARCHAR(64),
            toolg_id      VARCHAR(64),
            recipe        VARCHAR(64),
            reticle_group VARCHAR(64),
            step_type     VARCHAR(64),
            toolg_type    VARCHAR(64),
            ope_no        VARCHAR(64),
            capability    VARCHAR(4000),
            sgs_flag      VARCHAR(64),
            sgs_group     VARCHAR(64),
            ct            VARCHAR(64),
            pt            VARCHAR(64),
            ope_seq       VARCHAR(64)
        )
        """.format(table_type=table_type)
    duck_db.sql(sql)
    sql = """
            create {table_type} table APS_TMP_ETL_FLOW_MAIN_TOOL_RSDATA
            (
                prod_id       VARCHAR(64),
                plan_no       VARCHAR(64),
                plan_id       VARCHAR(64),
                step_id       VARCHAR(64),
                layer         VARCHAR(64),
                stage         VARCHAR(64),
                toolg_id      VARCHAR(64),
                recipe        VARCHAR(64),
                reticle_group VARCHAR(64),
                step_type     VARCHAR(64),
                toolg_type    VARCHAR(64),
                ope_no        VARCHAR(64),
                capability    VARCHAR(4000),
                sgs_flag      VARCHAR(64),
                sgs_group     VARCHAR(64),
                ct            VARCHAR(64),
                pt            VARCHAR(64),
                ope_seq       VARCHAR(64)
            )
            """.format(table_type=table_type)
    duck_db.sql(sql)
    sql = """
            create {table_type} table APS_TMP_ETL_FLOW_MAIN_PROD_RSDATA
            (
                prod_id       VARCHAR(64),
                plan_no       VARCHAR(64),
                plan_id       VARCHAR(64),
                step_id       VARCHAR(64),
                layer         VARCHAR(64),
                stage         VARCHAR(64),
                toolg_id      VARCHAR(64),
                recipe        VARCHAR(64),
                reticle_group VARCHAR(64),
                step_type     VARCHAR(64),
                toolg_type    VARCHAR(64),
                ope_no        VARCHAR(64),
                capability    VARCHAR(4000),
                sgs_flag      VARCHAR(64),
                prodg_id      VARCHAR(64),
                prodg_tech    VARCHAR(64),
                sgs_group     VARCHAR(64),
                ct            VARCHAR(64),
                pt            VARCHAR(64),
                ope_seq       VARCHAR(64)
            )
            """.format(table_type=table_type)
    duck_db.sql(sql)
    sql = """
       create {table_type} table APS_TMP_ETL_FLOW_PO_N1_RECYCLE
       (
            pos_pdid          VARCHAR(64) not null,
            mainpd_id         VARCHAR(64) not null,
            ope_no            VARCHAR(64) not null,
            ope_seq           VARCHAR(64),
            multi_group       VARCHAR(64),
            multi_target_flag VARCHAR(64)
       )
       """.format(table_type=table_type)
    duck_db.sql(sql)
    sql = """
       create {table_type} table APS_TMP_ETL_FLOW_SKIP_FLAG
       (
            plan_id VARCHAR(64),
            ope_no  VARCHAR(64)
       )
       """.format(table_type=table_type)
    duck_db.sql(sql)
    sql = """
       create {table_type} table APS_TMP_ETL_FLOW_ANNOTATION_BRANCH
       (
              prod_id       VARCHAR(64),
              plan_no       VARCHAR(64),
              plan_id       VARCHAR(64),
              step_id       VARCHAR(64),
              layer         VARCHAR(64),
              stage         VARCHAR(64),
              toolg_id      VARCHAR(64),
              recipe        VARCHAR(64),
              reticle_group VARCHAR(64),
              step_type     VARCHAR(64),
              toolg_type    VARCHAR(64),
              ope_no        VARCHAR(64),
              capability    VARCHAR(512),
              sgs_flag      VARCHAR(64),
              prodg_id      VARCHAR(64),
              prodg_tech    VARCHAR(64),
              process_time  VARCHAR(64),
              cycle_time    VARCHAR(64),
              sgs_group     VARCHAR(64),
              main_plan_id  VARCHAR(64),
              entry_step_id VARCHAR(64),
              retn_step_id  VARCHAR(64)
       )
       """.format(table_type=table_type)
    duck_db.sql(sql)

# 获取APS_TMP_TYPE11_MEDIAN
def GetType11MedianDataSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
         INSERT INTO {tempdb}APS_TMP_ETL_FLOW_TYPE11_MEDIAN(                                          
                     CYCLE_TIME, PROCESS_TIME, PROD_ID, OPE_NO, TOOLG_ID                                                                        
        )                                                                                               
         SELECT CYCLE_TIME,PROCESS_TIME,                                                                                 
                PROD_ID,OPE_NO,TOOLG_ID                                                                                          
         FROM APS_TMP_TYPE11_MEDIAN.APS_TMP_TYPE11_MEDIAN                                                                                             
        """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_TYPE11_MEDIAN",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_TYPE11_MEDIAN")
    if config.g_debug_mode:
        print("446")


# 获取APS_TMP_TYPE12_MEDIAN
def GetType12MedianDataSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
      INSERT INTO {tempdb}APS_TMP_ETL_FLOW_TYPE12_MEDIAN(                                          
         CYCLE_TIME, PROCESS_TIME, TOOLG_ID                                                                               
         )                                                                                               
          SELECT CYCLE_TIME,PROCESS_TIME,                                                                                 
                 TOOLG_ID                                                                                                         
          FROM APS_TMP_TYPE12_MEDIAN.APS_TMP_TYPE12_MEDIAN                        
        """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_TYPE12_MEDIAN",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_TYPE12_MEDIAN")


# 先保存V_ETL_FLOW数据
def GetViewFlowSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
        INSERT INTO {tempdb}APS_TMP_ETL_FLOW_VIEW_FLOW(       
             MNPD_ID, MNPD_VS, PRODG1, PRODSPEC_ID, OPE_NO, OPE_SEQ,
             SCHE_EQP_G, EQP_G, INLINE_CT, INLINE_CYC_ACC, INLINE_CYC_REMAIN,
             TC, UPDATE_TIME, STD_CT, SGS_FLAG, SGS_GROUP, SGS_FIRST_OP, 
             SGS_WEIGHT, SGS_END_OP, SGS_LOOP_GROUP, INLINE_PROC_TIME                                         
        )                                                        
         SELECT                                                 
               MNPD_ID,MNPD_VS,PRODG1,PRODSPEC_ID,              
               OPE_NO,OPE_SEQ,
               --SCHE_EQP_G,EQP_G,     
               --modify by xiecheng for version up
                -- TRIM(REPLACE(SCHE_EQP_G,CHR(49824),'')) AS SCHE_EQP_G,     
                -- TRIM(REPLACE(EQP_G,CHR(49824),'')) AS EQP_G,
                TRIM(REPLACE(SCHE_EQP_G,CHR(160),'')) AS SCHE_EQP_G,     
                TRIM(REPLACE(EQP_G,CHR(160),'')) AS EQP_G,       
               INLINE_CT,INLINE_CYC_ACC,                        
               INLINE_CYC_REMAIN,TC,                            
               UPDATE_TIME,STD_CT,SGS_FLAG,                     
               SGS_GROUP,SGS_FIRST_OP,SGS_WEIGHT,               
               SGS_END_OP,SGS_LOOP_GROUP, INLINE_PROC_TIME      
         FROM APS_SYNC_FLOW.APS_SYNC_FLOW                                                                                                         
    """.format(uuid=uuid, current_time=current_time, tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_VIEW_FLOW",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_VIEW_FLOW")


# 先把V_PF_PO_N1保存
def GetPoN1Sql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
        INSERT INTO {tempdb}APS_TMP_ETL_FLOW_PO_N1(                           
          POS_PDID, MAINPD_ID, OPE_NO, OPE_SEQ, MULTI_GROUP, MULTI_TARGET_FLAG                                              
         )                                                                    
          SELECT N.POS_PDID,N.MAINPD_ID,N.OPE_NO,N.OPE_SEQ,                   
                 N.BATCH_NAME,N.BATCH_TARGET_FLAG                                    
          FROM APS_SYNC_PF_PO_N1.APS_SYNC_PF_PO_N1 N                                                                 
    """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_PO_N1",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_PO_N1")


# 先把V_PF_PO_N1保存(针对Dummy/Recycle/Equipment Monitor)
def GetRecyclePoN1Sql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
           INSERT INTO {tempdb}APS_TMP_ETL_FLOW_PO_N1_RECYCLE(                       
         POS_PDID, MAINPD_ID, OPE_NO, OPE_SEQ, MULTI_GROUP, MULTI_TARGET_FLAG                                                     
         )                                                                    
           SELECT N.POS_PDID,N.MAINPD_ID,N.OPE_NO,                            
                  N.OPE_SEQ,N.MULTI_GROUP,                                    
                  N.MULTI_TARGET_FLAG                                         
           FROM  {tempdb}APS_TMP_ETL_FLOW_PO_N1 N                                  
           WHERE NOT EXISTS (                                                 
                 SELECT 1                                                     
                 FROM APS_SYNC_FLOW.APS_SYNC_FLOW F              
                 WHERE F.MNPD_ID = N.MAINPD_ID
                 --modify by xiecheng for version up                                
                 --AND F.OPE_NO = N.OPE_NO                                                        
                 )                                                            
           AND position('B' in N.MAINPD_ID) <> 1                                    
           AND position('Y' in N.MAINPD_ID) <> 1                                    
           AND position('DYB' in N.MAINPD_ID) <> 1                                                                                                                                                                                                                       
         """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_PO_N1_RECYCLE",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_PO_N1_RECYCLE")


# 先把V_PD_RECIPE_EQP_MAIN/V_PD_RECIPE_EQP_REWORK保存
def GetRecipeEqpLoadSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
        INSERT INTO {tempdb}APS_TMP_ETL_FLOW_EQP_LOAD(                        
         EQP_ID, LCRECIPE_ID, PD_ID, PRODSPEC_ID, EQP_G, EQP_CATEGORY                                                          
        )                                                                       
         SELECT MAX(L.EQP_ID) AS EQP_ID,MAX(L.LCRECIPE_ID) AS LCRECIPE_ID,                       
                L.PD_ID,L.PRODSPEC_ID,T.EQP_G,                                  
                MAX(T.EQP_CATEGORY) AS EQP_CATEGORY                                      
         FROM APS_SYNC_PD_RECIPE_EQP_MAIN.APS_SYNC_PD_RECIPE_EQP_MAIN L               
         INNER JOIN APS_SYNC_ETL_TOOL.APS_SYNC_ETL_TOOL T                  
         ON T.EQP_ID = L.EQP_ID                                                 
         WHERE T.HOST_EQP_FLAG='Y'     
         GROUP BY L.PRODSPEC_ID,T.EQP_G,L.PD_ID 
        --modify by xiecheng for version up                             
         --UNION                                                                  
        -- SELECT MAX(L.EQP_ID) AS EQP_ID,MAX(L.LCRECIPE_ID) AS LCRECIPE_ID,                       
           --     L.PD_ID,L.PRODSPEC_ID,T.EQP_G,                                  
            --    MAX(T.EQP_CATEGORY) AS EQP_CATEGORY                                      
      --   FROM APS_SYNC_PD_RECIPE_EQP_REWORK.APS_SYNC_PD_RECIPE_EQP_REWORK L               
        -- INNER JOIN APS_SYNC_ETL_TOOL.APS_SYNC_ETL_TOOL T                  
       --  ON T.EQP_ID = L.EQP_ID                                                 
       --  WHERE T.HOST_EQP_FLAG='Y'     
       --  GROUP BY L.PRODSPEC_ID,T.EQP_G,L.PD_ID                                                                                                                                                                                        
     """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_EQP_LOAD",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_EQP_LOAD")


# backUpEqp先获取出来
def GetFlowByBackUpEqpSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
    INSERT INTO {tempdb}APS_TMP_ETL_FLOW_BACKUPEQP(                                             
                EQP_G, PRODUCTID, OPENO, ROUTEID, RECIPE                                                                   
        )                                                                                                
         WITH BACK_EQPG AS (                                                                            
           SELECT  (CASE WHEN (SUBSTRING(SUBSTRING(N.OPE_NO, POSITION('.' IN N.OPE_NO)),3,1)='Q' AND            
             L.EQP_G IN ('PK_KrF','PH_ArF','PU_I-Line')) THEN 'None' ELSE L.EQP_G END) AS EQP_G,        
             L.PRODSPEC_ID,                                                                             
             N.OPE_NO,                                                                                  
             N.MAINPD_ID,                                                                               
             L.LCRECIPE_ID                                                                              
           FROM {tempdb}APS_TMP_ETL_FLOW_PO_N1 N, {tempdb}APS_TMP_ETL_FLOW_EQP_LOAD L,                            
                {tempdb}APS_TMP_ETL_FLOW_VIEW_FLOW F                                                         
           WHERE N.POS_PDID = L.PD_ID                                                                   
           AND F.MNPD_ID = N.MAINPD_ID AND F.PRODSPEC_ID = L.PRODSPEC_ID                                
           AND F.OPE_NO = N.OPE_NO                                                                      
         )                                                                                              
         SELECT EQP_G,                                                                                  
                PRODSPEC_ID,                                                                            
                OPE_NO,                                                                                 
                MAINPD_ID,                                                                              
                MAX(LCRECIPE_ID) AS LCRECIPE_ID                                                         
         FROM BACK_EQPG CT                                                                              
         GROUP BY EQP_G,PRODSPEC_ID,OPE_NO,MAINPD_ID                                                                            
    """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_BACKUPEQP",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_BACKUPEQP")


# 获取RWK和SUB Flow出来
def GetSubAndRewFlowSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
        INSERT INTO {tempdb}APS_TMP_ETL_FLOW_REAL_RWK_SUB(                              
             PROD_ID, PLAN_NO, PLAN_ID, STEP_ID,OPE_NO,EQP_ID,RECIPE,STEP_TYPE,TOOLG_ID,TOOLG_TYPE                                                                     
             )                                                                                    
              SELECT BB.PRODSPEC_ID AS PROD_ID,                                                                                                            
                        '1' AS PLAN_NO,                                                                                                                      
                        AA.MAINPD_ID AS PLAN_ID,                                                                                                             
                        --'.'|| LPAD(CAST(CAST(MAX(AA.OPE_SEQ) AS DECIMAL) AS DECIMAL(4,0)),4,'0') || '.0000' AS STEP_ID,   
                        printf('.%09.4f',cast(CAST(MAX(AA.OPE_SEQ) AS DECIMAL) as float)) AS STEP_ID,                                                                       
                        AA.OPE_NO,                                                                                                                            
                        MAX(BB.EQP_ID) EQP_ID,                                                                                                               
                        MAX(BB.LCRECIPE_ID) AS RECIPE,                                                                                                       
                        CASE WHEN SUBSTRING(AA.MAINPD_ID,1,1) = 'B' THEN 'I' ELSE 'R' END AS STEP_TYPE,  
                        BB.EQP_G AS TOOLG_ID,                                                     
                        MAX(BB.EQP_CATEGORY) AS TOOLG_TYPE                                                                                                                
              FROM {tempdb}APS_TMP_ETL_FLOW_PO_N1 AA                                                                                                           
              INNER JOIN {tempdb}APS_TMP_ETL_FLOW_EQP_LOAD BB                                                                                                  
              ON AA.POS_PDID = BB.PD_ID                                                                                                                             
              WHERE  POSITION('B' IN AA.MAINPD_ID) = 1 OR POSITION('Y' IN AA.MAINPD_ID) = 1                                                                       
              GROUP BY AA.MAINPD_ID,AA.OPE_NO,BB.PRODSPEC_ID,BB.EQP_G                                                                                                                                                
        """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_REAL_RWK_SUB",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_REAL_RWK_SUB")


#  获取(针对Dummy/Recycle/Equipment Monitor) Flow出来
def GetRecycleFlowSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
           INSERT INTO {tempdb}APS_TMP_ETL_FLOW_REAL_RWK_SUB(                              
                PROD_ID, PLAN_NO, PLAN_ID, STEP_ID,OPE_NO,EQP_ID,RECIPE,STEP_TYPE,TOOLG_ID,TOOLG_TYPE                                                                     
                )                                                                                    
                 SELECT BB.PRODSPEC_ID AS PROD_ID,                                                                                                            
                           '1' AS PLAN_NO,                                                                                                                      
                           AA.MAINPD_ID AS PLAN_ID,                                                                                                             
                           -- '.'||TRIM(' ' from   FORMAT(CAST(MAX(AA.OPE_SEQ) AS DECIMAL), '0000.0000')) AS STEP_ID,
                           -- '.'|| LPAD(CAST(CAST(MAX(AA.OPE_SEQ) AS DECIMAL) AS DECIMAL(4,0)),4,'0') || '.0000' AS STEP_ID,                          
                            printf('.%09.4f',cast(CAST(MAX(AA.OPE_SEQ) AS DECIMAL) as float)) AS STEP_ID,
                           --CASE WHEN LENGTH(AA.OPE_SEQ)<10 THEN '.'||AA.OPE_SEQ ELSE AA.OPE_SEQ END AS STEP_ID,                                                                         
                           AA.OPE_NO,                                                                                                                           
                           MAX(BB.EQP_ID) EQP_ID,                                                                                                               
                           MAX(BB.LCRECIPE_ID) AS RECIPE,                                                                                                       
                           'N' AS STEP_TYPE, 
                           BB.EQP_G AS TOOLG_ID,                                                     
                           MAX(BB.EQP_CATEGORY) AS TOOLG_TYPE                                                                                                                
                 FROM {tempdb}APS_TMP_ETL_FLOW_PO_N1_RECYCLE AA                                                                                                           
                 INNER JOIN {tempdb}APS_TMP_ETL_FLOW_EQP_LOAD BB                                                                                                  
                 ON AA.POS_PDID = BB.PD_ID                                                                                                                                                                                                  
                 GROUP BY AA.MAINPD_ID,AA.OPE_NO,BB.PRODSPEC_ID,BB.EQP_G                                                                                                                                              
           """.format(tempdb=my_duck.get_temp_table_mark())
    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_REAL_RWK_SUB",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_REAL_RWK_SUB")


# 获取SUB/REWORK的备援机台信息
def GetSubAndRewFlowBackUpEqpSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
        INSERT INTO {tempdb}APS_TMP_ETL_FLOW_SUB_BACKUPEQP(                                   
             PROD_ID, OPE_NO, TOOLG_ID, PLAN_ID, BACKUP_EQP                                                                               
            )                                                                                             
             WITH SUB_REWORK_DATA AS (                                                                    
                 SELECT DISTINCT PROD_ID,OPE_NO,TOOLG_ID,PLAN_ID                                                                                       
                 FROM {tempdb}APS_TMP_ETL_FLOW_REAL_RWK_SUB                                              
             ),                                                                                           
             BACKUP_EQP_DATA AS (                                                                         
                  SELECT PROD_ID,OPE_NO,TOOLG_ID,PLAN_ID,     
                   -- REPLACE( STRING_AGG(TOOLG_ID,',' OVER(PARTITION BY PROD_ID,OPE_NO,PLAN_ID ORDER BY TOOLG_ID)) , TOOLG_ID) AS BACKUP_EQP   
                   -- REPLACE(STRING_AGG(TOOLG_ID,',') OVER (PARTITION BY PROD_ID,OPE_NO,PLAN_ID ORDER BY TOOLG_ID), TOOLG_ID, '') AS BACKUP_EQP
                   replace(
                   (
                   select STRING_AGG(TOOLG_ID,',') OVER (PARTITION BY PROD_ID,OPE_NO,PLAN_ID ORDER BY TOOLG_ID)
                      from SUB_REWORK_DATA ssss
                      where SUB_REWORK_DATA.PROD_ID = ssss.PROD_ID
                      AND SUB_REWORK_DATA.OPE_NO = ssss.OPE_NO
                      AND SUB_REWORK_DATA.PLAN_ID = ssss.PLAN_ID
                   ), TOOLG_ID, ''
                   )  as BACKUP_EQP
                      
                   FROM SUB_REWORK_DATA                                                                   
             )                                                                                                        
             SELECT PROD_ID,OPE_NO,TOOLG_ID,PLAN_ID,                                                      
                    CASE WHEN BA.BACKUP_EQP = ',' THEN NULL                                               
                       WHEN POSITION(',' IN BA.BACKUP_EQP) =1 THEN SUBSTRING(BA.BACKUP_EQP,2,LENGTH(BA.BACKUP_EQP))  
                       WHEN BA.BACKUP_EQP LIKE '%,' THEN SUBSTRING(BA.BACKUP_EQP,1,LENGTH(BA.BACKUP_EQP))  
                       WHEN BA.BACKUP_EQP LIKE '%,,%' THEN REPLACE (BA.BACKUP_EQP,',,',',')               
                       ELSE BA.BACKUP_EQP END AS BACKUP_EQP                                               
             FROM BACKUP_EQP_DATA BA                                                                                 
    """.format(tempdb=my_duck.get_temp_table_mark())
    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_SUB_BACKUPEQP",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_SUB_BACKUPEQP")


# 获取RECIPE出来
def GetFlowByRecipeSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
        INSERT INTO {tempdb}APS_TMP_ETL_FLOW_RECIPE(   
        LCRECIPE_ID, OPE_NO, PRODSPEC_ID, MNPD_ID, EQP_G                                   
        )                                                   
         SELECT MAX(P.RECIPE) AS RECIPE,                   
                P.OPENO,                                   
                P.PRODUCTID,                               
                P.ROUTEID,                                 
                P.EQP_G                                    
         FROM {tempdb}APS_TMP_ETL_FLOW_BACKUPEQP P            
         GROUP BY P.OPENO,P.PRODUCTID,                     
                  P.ROUTEID,P.EQP_G                                                                                                                                                                    
    """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_RECIPE",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_RECIPE")


#  获取V_MASK_GROUP_MAPPLING信息
def GetMaskGroupMapSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
        INSERT INTO {tempdb}APS_TMP_ETL_FLOW_MASK_GROUP(                                                
         PRODSPEC_ID, OPE_NO, MASK_GROUP                                                                            
         )                                                                                           
          SELECT M.PRODSPEC_ID ,M.OPE_NO, MAX(M.RTCL_GROUP) AS MASK_GROUP                           
          FROM APS_SYNC_MASK_GROUP_MAPPLING.APS_SYNC_MASK_GROUP_MAPPLING M                                                                             
          GROUP BY M.PRODSPEC_ID ,M.OPE_NO                                                                                                                                                    
       """.format(tempdb=my_duck.get_temp_table_mark())
    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_MASK_GROUP",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_MASK_GROUP")


# 获取V_PRODUCT的信息
def GetProductSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
        INSERT INTO {tempdb}APS_TMP_ETL_FLOW_PROD_DATA(                                                 
             PRODG_ID, PRODG_TECH, PRODSPEC_ID                                                            
           )                                                                                           
            SELECT MAX(PRODG1) AS PRODG_ID, MAX(GROUP_TECH) AS PRODG_TECH,PRODSPEC_ID                 
            FROM APS_SYNC_PRODUCT.APS_SYNC_PRODUCT                                                                                           
            GROUP BY PRODSPEC_ID                                            
          """.format(tempdb=my_duck.get_temp_table_mark())
    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_PROD_DATA",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_PROD_DATA")


# 获取TOOL分组信息
def GetToolGroupSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """      
      INSERT INTO {tempdb}APS_TMP_ETL_FLOW_TOOL_GROUP(                                                 
         TOOLG_TYPE, EQP_G                                                                   
       )                                                                                            
        SELECT MAX(EQP_CATEGORY) AS TOOLG_TYPE,EQP_G                                               
        FROM APS_SYNC_ETL_TOOL.APS_SYNC_ETL_TOOL                                                                                         
        GROUP BY EQP_G                                                                                        
          """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_TOOL_GROUP",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_TOOL_GROUP")


# 获取FLow的备援机群主信息
def getMainFlowRSData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """      
         INSERT  /*+ append */ INTO {tempdb}APS_TMP_ETL_FLOW_MAIN_RSDATA(                                           
           RECIPE, PRODSPEC_ID, MNPD_ID, OPE_NO, EQP_G,OPE_SEQ, CAPABILITY, SGS_FLAG, TOOLG_TYPE, SGS_GROUP, CT, PT                                                                              
          )                                                                                            
          WITH FLOW AS (                                                                                                                                     
               SELECT CC.PRODSPEC_ID AS PRODSPEC_ID,                                                                                                          
               CC.MNPD_ID,CC.OPE_NO,                                                                                                                          
               (CASE WHEN (SUBSTRING(SUBSTRING(CC.OPE_NO, position('.' in CC.OPE_NO)),3,1)='Q' AND                                                                   
               CC.EQP_G IN ('PK_KrF','PH_ArF','PU_I-Line')) THEN 'None' ELSE CC.EQP_G END) AS EQP_G,                                                          
               (CASE WHEN (SUBSTRING(SUBSTRING(CC.OPE_NO, position('.' in CC.OPE_NO)),3,1)='Q' AND                                                                   
               CC.EQP_G IN ('PK_KrF','PH_ArF','PU_I-Line')) THEN 'M' ELSE '' END) AS TOOLG_TYPE,                                                              
               CC.OPE_SEQ,                                                                                                                                    
               CASE WHEN CC.SGS_FLAG='Y' AND CC.SGS_FIRST_OP='Y' THEN 'YF' ELSE (CASE WHEN CC.SGS_FLAG='Y'                                                    
               AND (CC.SGS_FIRST_OP IS NULL OR CC.SGS_FIRST_OP ='' OR CC.SGS_FIRST_OP <> 'Y') THEN 'Y' ELSE NULL END) END AS SGS_FLAG,                                                 
               CC.SGS_GROUP,CC.INLINE_CT,CC.INLINE_PROC_TIME                                                                                                  
               FROM {tempdb}APS_TMP_ETL_FLOW_VIEW_FLOW CC                                                                                                          
               WHERE SUBSTRING(CC.PRODSPEC_ID,LENGTH(CC.PRODSPEC_ID)) <> '_'                                                                       
            ),
            flow_ss as (
               SELECT  MAX(AA.LCRECIPE_ID) AS RECIPE,CC.PRODSPEC_ID,CC.MNPD_ID,                                                                                 
             			 CC.OPE_NO AS OPE_NO,MAX(CC.EQP_G) AS EQP_G, CC.OPE_SEQ,   
                    	MAX(CC.SGS_FLAG) AS SGS_FLAG, MAX(CC.TOOLG_TYPE) AS TOOLG_TYPE,                                                                                 
             		 	MAX(CC.SGS_GROUP) AS  SGS_GROUP,                                                                                                                
              			MAX(CC.INLINE_CT) AS CT,                                                                                                                        
             			MAX(CC.INLINE_PROC_TIME) AS PT                 
               FROM FLOW CC                                                                                                                                    
              LEFT JOIN  {tempdb}APS_TMP_ETL_FLOW_RECIPE AA                                                                                                  
              ON CC.MNPD_ID = AA.MNPD_ID AND CC.OPE_NO = AA.OPE_NO                                                                                            
              AND CC.PRODSPEC_ID = AA.PRODSPEC_ID AND CC.EQP_G = AA.EQP_G                                                                                     
              LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_BACKUPEQP BA                                                                                                
              ON BA.PRODUCTID = CC.PRODSPEC_ID AND BA.OPENO = CC.OPE_NO                                                                                       
              AND BA.EQP_G <> CC.EQP_G AND BA.ROUTEID = CC.MNPD_ID 
              GROUP BY CC.PRODSPEC_ID,CC.OPE_NO,CC.MNPD_ID,CC.OPE_SEQ   
            )
              SELECT DISTINCT  ss.RECIPE,ss.PRODSPEC_ID,ss.MNPD_ID,                                                                                 
             ss.OPE_NO, ss.EQP_G, ss.OPE_SEQ,                                                                                         
             STRING_AGG(BA.EQP_G,',') over(PARTITION BY ss.PRODSPEC_ID,ss.OPE_NO,ss.MNPD_ID,ss.OPE_SEQ) AS CAPABILITY,                     
              ss.SGS_FLAG,  ss.TOOLG_TYPE,                                                                                 
               ss.SGS_GROUP,                                                                                                                
               ss.CT,                                                                                                                        
               ss.PT          
              FROM flow_ss ss                                                                                                                                                                                                                       
              LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_BACKUPEQP BA                                                                                                
              ON BA.PRODUCTID = ss.PRODSPEC_ID AND BA.OPENO = ss.OPE_NO                                                                                       
              AND BA.EQP_G <> ss.EQP_G AND BA.ROUTEID = ss.MNPD_ID                                                                         
              """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_MAIN_RSDATA",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_MAIN_RSDATA")


# 把主Flow的数据两两拆开
# ①Mask_Group串接
def getMainFlowRSByMaskData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """      
        INSERT  /*+ append */ INTO {tempdb}APS_TMP_ETL_FLOW_MAIN_MASK_RSDATA(                                           
        PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER, STAGE, TOOLG_ID, RECIPE, RETICLE_GROUP, 
        STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG, SGS_GROUP, CT, PT, OPE_SEQ                                                                             
        )                                                                                            
              SELECT FL.PRODSPEC_ID AS PROD_ID, '1' AS PLAN_NO, FL.MNPD_ID AS PLAN_ID,                                                                      
              --TRIM(FORMAT(CAST(FL.OPE_SEQ AS DECIMAL), '0000.0000')) AS STEP_ID,   
               --LPAD(CAST(CAST(FL.OPE_SEQ AS DECIMAL) AS DECIMAL(4,0)),4,'0') || '.0000' AS STEP_ID,
               printf('%09.4f',cast(CAST(FL.OPE_SEQ AS DECIMAL) as float)) AS STEP_ID,
              --CASE WHEN LENGTH(FL.OPE_SEQ)<10 THEN '.'||FL.OPE_SEQ ELSE FL.OPE_SEQ END AS STEP_ID,                                                                                         
              SUBSTRING(FL.OPE_NO, 1, POSITION('.' IN FL.OPE_NO)-1) AS LAYER,                                                                                     
              SUBSTRING(FL.OPE_NO, POSITION('.' IN FL.OPE_NO)+1) AS STAGE,                                                                                        
              COALESCE(FL.EQP_G,'None') AS TOOLG_ID, FL.RECIPE AS RECIPE, MI.MASK_GROUP AS RETICLE_GROUP,                                                        
              'N' AS STEP_TYPE, FL.TOOLG_TYPE,                                                                                                   
              FL.OPE_NO AS OPE_NO, FL.CAPABILITY AS CAPABILITY, FL.SGS_FLAG,                                                       
              FL.SGS_GROUP,FL.CT,FL.PT,FL.OPE_SEQ                                                                                  
              FROM {tempdb}APS_TMP_ETL_FLOW_MAIN_RSDATA FL                                                                         
              LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_MASK_GROUP MI ON FL.PRODSPEC_ID = MI.PRODSPEC_ID AND FL.OPE_NO = MI.OPE_NO                                                                                                              
           """.format(tempdb=my_duck.get_temp_table_mark())
    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_MAIN_MASK_RSDATA",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_MAIN_MASK_RSDATA")


# ①Tool_Group串接
def getMainFlowRSByToolData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """      
        INSERT  /*+ append */ INTO {tempdb}APS_TMP_ETL_FLOW_MAIN_TOOL_RSDATA(                                            
             PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER, STAGE, TOOLG_ID, RECIPE, RETICLE_GROUP, 
             STEP_TYPE, TOOLG_TYPE,OPE_NO, CAPABILITY, SGS_FLAG, SGS_GROUP, CT, PT, OPE_SEQ                                                                              
             )                                                                                             
                   SELECT FL.PROD_ID, FL.PLAN_NO, FL.PLAN_ID,                                                                       
                   FL.STEP_ID,                                                                                              
                   FL.LAYER,                                                                                      
                   FL.STAGE,                                                                                         
                   FL.TOOLG_ID, FL.RECIPE, FL.RETICLE_GROUP,                                                         
                   FL.STEP_TYPE, ( CASE WHEN FL.TOOLG_TYPE IS NOT NULL and FL.TOOLG_TYPE <> '' THEN FL.TOOLG_TYPE ELSE  
                    --modify by xiecheng for version up 
                   (CASE WHEN TL.TOOLG_TYPE= 'Process' THEN 'P' 
                         WHEN TL.TOOLG_TYPE='Measurement' THEN 'M'
                         WHEN TL.TOOLG_TYPE='Internal Buffer' THEN 'P'
                         WHEN TL.TOOLG_TYPE='Wafer Bonding' THEN 'P'
                         WHEN TL.TOOLG_TYPE='Wafer Sorter' THEN 'M' ELSE ''  END) END) AS TOOLG_TYPE,                                                                                               
                   FL.OPE_NO, FL.CAPABILITY, FL.SGS_FLAG,                                                                                                         
                   FL.SGS_GROUP,FL.CT,FL.PT,FL.OPE_SEQ                                                                                                            
                   FROM {tempdb}APS_TMP_ETL_FLOW_MAIN_MASK_RSDATA FL                                                                                                   
                   LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_TOOL_GROUP TL ON FL.TOOLG_ID = TL.EQP_G                                                                                                                                                                                 
               """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_MAIN_TOOL_RSDATA",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_MAIN_TOOL_RSDATA")


# ①Prod_Data串接
def getMainFlowRSByProdData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """      
        INSERT  /*+ append */ INTO {tempdb}APS_TMP_ETL_FLOW_MAIN_PROD_RSDATA(                                           
             PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER, STAGE, TOOLG_ID, RECIPE, RETICLE_GROUP, 
             STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG, PRODG_ID, PRODG_TECH, SGS_GROUP, CT, PT, OPE_SEQ                                                                      
             )                                                                                            
                   SELECT FL.PROD_ID, FL.PLAN_NO, FL.PLAN_ID,                                                                      
                   FL.STEP_ID,                                                                                             
                   FL.LAYER,                                                                                     
                   FL.STAGE,                                                                                        
                   FL.TOOLG_ID, FL.RECIPE, FL.RETICLE_GROUP,                                                        
                   FL.STEP_TYPE,                                                                
                   FL.TOOLG_TYPE,                                                               
                   FL.OPE_NO, FL.CAPABILITY, FL.SGS_FLAG, P.PRODG_ID, P.PRODG_TECH,             
                   FL.SGS_GROUP,FL.CT,FL.PT,FL.OPE_SEQ                                                                                                           
                   FROM {tempdb}APS_TMP_ETL_FLOW_MAIN_TOOL_RSDATA FL                                                                                                  
                   LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_PROD_DATA P ON P.PRODSPEC_ID = FL.PROD_ID                                                                                                                                                                                
                   """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_MAIN_PROD_RSDATA",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_MAIN_PROD_RSDATA")


# 把Rework串接Flow的部分拆开
def getRewDataByFlow(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """      
        INSERT  /*+ append */ INTO {tempdb}APS_TMP_ETL_FLOW_REWORK_RSDATA(                                            
             PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER, STAGE, TOOLG_ID, RECIPE, RETICLE_GROUP, STEP_TYPE, TOOLG_TYPE,
             SGS_FLAG, SGS_GROUP, OPE_NO, PRODG_ID, PRODG_TECH, INLINE_CT, INLINE_PROC_TIME                                                                              
             )                                                                                           
               SELECT F.PROD_ID,                                                                                                                            
                      F.PLAN_NO,                                                                                                                            
                      F.PLAN_ID,                                                                                                                            
                      F.STEP_ID,                                                                                                                            
                      SUBSTRING(F.OPE_NO, 1, POSITION('.' IN F.OPE_NO) -1) AS LAYER,                                                                               
                      SUBSTRING(F.OPE_NO, POSITION('.' IN F.OPE_NO) +1) AS STAGE,                                                                                  
                      F.TOOLG_ID,                                                                                                                           
                      F.RECIPE,                                                                                                                             
                      M.MASK_GROUP AS RETICLE_GROUP,                                                                                                                      
                      F.STEP_TYPE,     
                      --modify by xiecheng for version up                                                                                                                  
                      (CASE WHEN F.TOOLG_TYPE= 'Process' THEN 'P' 
                             WHEN F.TOOLG_TYPE='Measurement' THEN 'M'
                             WHEN F.TOOLG_TYPE='Internal Buffer' THEN 'P'
                             WHEN F.TOOLG_TYPE='Wafer Bonding' THEN 'P' 
                             WHEN F.TOOLG_TYPE='Wafer Sorter' THEN 'M' ELSE '' END) AS TOOLG_TYPE,                     
                      CASE WHEN FL.SGS_FLAG='Y' AND FL.SGS_FIRST_OP='Y' THEN 'YF' ELSE (CASE WHEN FL.SGS_FLAG='Y'                                           
                      AND (FL.SGS_FIRST_OP IS NULL OR FL.SGS_FIRST_OP ='' OR FL.SGS_FIRST_OP <> 'Y') THEN 'Y' ELSE NULL END) END AS SGS_FLAG,                                        
                      FL.SGS_GROUP,                                                                                                                         
                      F.OPE_NO,                                                                                                                             
                      P.PRODG_ID,                                                                                                                           
                      P.PRODG_TECH,                                                                                                                         
                      FL.INLINE_CT,                                                                                                                         
                      FL.INLINE_PROC_TIME                                                                                                                   
               FROM {tempdb}APS_TMP_ETL_FLOW_REAL_RWK_SUB F                                                                                                   
               LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_MASK_GROUP M                                                                                                   
               ON M.PRODSPEC_ID = F.PROD_ID                                                                                                                 
               AND M.OPE_NO = F.OPE_NO                                                                                                                      
               LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_PROD_DATA P                                                                                                    
               ON P.PRODSPEC_ID = F.PROD_ID                                                                                                                 
               LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_VIEW_FLOW FL                                                                                                   
               ON FL.PRODSPEC_ID = F.PROD_ID  AND FL.OPE_NO = F.OPE_NO                                                                                                                                                                                
               """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_REWORK_RSDATA",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_REWORK_RSDATA")


# 把Rework串接Flow的部分拆开
def getRewBackUpEqpData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """      
        INSERT  /*+ append */ INTO {tempdb}APS_TMP_ETL_FLOW_REWORK_BACKUPEQP_RSDATA(                                            
            PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER, STAGE, TOOLG_ID, RECIPE, RETICLE_GROUP, STEP_TYPE, TOOLG_TYPE,
            SGS_FLAG, SGS_GROUP, OPE_NO, PRODG_ID, PRODG_TECH, INLINE_CT, INLINE_PROC_TIME, BACKUP_EQP                                                                              
         )                                                                                             
            SELECT F.PROD_ID,                                                                                                                            
                  F.PLAN_NO,                                                                                                                            
                  F.PLAN_ID,                                                                                                                            
                  F.STEP_ID,                                                                                                                            
                  F.LAYER,                                                                               
                  F.STAGE,                                                                                  
                  F.TOOLG_ID,                                                                                                                           
                  F.RECIPE,                                                                                                                             
                  F.RETICLE_GROUP,                                                                                                                      
                  F.STEP_TYPE,                                                                                                                          
                  F.TOOLG_TYPE,                                      
                  F.SGS_FLAG,                                        
                  F.SGS_GROUP,                                                                                                                         
                  F.OPE_NO,                                                                                                                             
                  F.PRODG_ID,                                                                                                                           
                  F.PRODG_TECH,                                                                                                                         
                  F.INLINE_CT,                                                                                                                         
                  F.INLINE_PROC_TIME,                                                                                                                  
                  BA.BACKUP_EQP                                                                                                                         
           FROM {tempdb}APS_TMP_ETL_FLOW_REWORK_RSDATA F                                                                                                   
           LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_SUB_BACKUPEQP BA                                                                                         
           ON BA.PROD_ID = F.PROD_ID AND BA.OPE_NO = F.OPE_NO                                                                                           
           AND BA.TOOLG_ID = F.TOOLG_ID AND BA.PLAN_ID = F.PLAN_ID                                                                                                                                                                                                   
           """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_REWORK_BACKUPEQP_RSDATA",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_REWORK_BACKUPEQP_RSDATA")


def GetFirstMainFlowSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """      
         INSERT /*+ append */ INTO {tempdb}APS_TMP_ETL_FLOW(                                                                                        
            PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER, STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,
            STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG, PRODG_ID, PRODG_TECH, PROCESS_TIME,
            CYCLE_TIME, SGS_GROUP                                                                                                                                      
        )                                                                                                                                                    
         SELECT FD.PROD_ID, FD.PLAN_NO, FD.PLAN_ID,                                                                                                          
              FD.STEP_ID,                                                                                                                                    
              FD.LAYER,                                                                                                                                      
              FD.STAGE,                                                                                                                                      
              FD.TOOLG_ID, FD.RECIPE, FD.RETICLE_GROUP,                                                                                                      
              FD.STEP_TYPE, FD.TOOLG_TYPE,                                                                                                                   
              FD.OPE_NO,
              CASE WHEN LENGTH(FD.CAPABILITY) > 512 THEN SUBSTRING(FD.CAPABILITY,1,512) ELSE FD.CAPABILITY END AS CAPABILITY,                        
              FD.SGS_FLAG, FD.PRODG_ID, FD.PRODG_TECH,                                                                                                       
              COALESCE(ZWS.PROCESS_TIME,ZWST.PROCESS_TIME,ZWSO.PROCESS_TIME,ZWS2.PROCESS_TIME,0) AS PROCESS_TIME,                              
              COALESCE(ZWS.CYCLE_TIME,ZWST.CYCLE_TIME,ZWSO.CYCLE_TIME,ZWS2.CYCLE_TIME,0) AS CYCLE_TIME,                                            
              FD.SGS_GROUP                                                                                                                                   
              FROM {tempdb}APS_TMP_ETL_FLOW_MAIN_PROD_RSDATA FD                                                                                                                              
              LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_TYPE11_MEDIAN ZWS                                                                                                
              ON ZWS.PROD_ID = FD.PROD_ID AND ZWS.OPE_NO = FD.OPE_NO AND ZWS.TOOLG_ID = FD.TOOLG_ID  
              LEFT JOIN APS_TMP_TYPE11_TECH_MEDIAN.APS_TMP_TYPE11_TECH_MEDIAN ZWST 
              ON ZWST.PROD_TECH = FD.PRODG_TECH AND ZWST.OPE_NO = FD.OPE_NO AND ZWST.TOOLG_ID = FD.TOOLG_ID 
              LEFT JOIN APS_TMP_TYPE12_OPE_MEDIAN.APS_TMP_TYPE12_OPE_MEDIAN ZWSO
              ON ZWSO.OPE_NO = FD.OPE_NO AND ZWSO.TOOLG_ID = FD.TOOLG_ID                                                       
              LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_TYPE12_MEDIAN ZWS2                                                                                               
              ON ZWS2.TOOLG_ID = FD.TOOLG_ID                                                                                                                                                                                                        
              """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW")


# 获取RewFlow及SubFlow的信息
def GetFirstRwkToSubFlowSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """      
       INSERT /*+ append */ INTO {tempdb}APS_TMP_ETL_FLOW(                                                    
            PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER, STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,
            STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG, PRODG_ID, PRODG_TECH, PROCESS_TIME,
            CYCLE_TIME, SGS_GROUP                                                                                                   
        )                                                                                                                 
       WITH ALLFLOW_DATA AS (                                                                                                                             
            SELECT F.PROD_ID,                                                                                                                          
                   F.PLAN_NO,                                                                                                                          
                   F.PLAN_ID,    
                   --modify by xiecheng for version up                                                                                                                      
                   F.STEP_ID,                                                                                                          
                   F.LAYER,                                                                                                              
                   F.STAGE,                                                                                                              
                   F.TOOLG_ID,                                                                                                        
                   F.RECIPE,                                                                                                            
                   F.RETICLE_GROUP,                                                                                              
                   F.STEP_TYPE,                                                                                                      
                   F.TOOLG_TYPE,                                                                                                    
                   F.SGS_FLAG,                                                                                                        
                   F.SGS_GROUP,                                                                                                      
                   F.OPE_NO,                                                                                                                           
                   F.BACKUP_EQP AS CAPABILITY,                                                                                                    
                   F.PRODG_ID,                                                                                                        
                   F.PRODG_TECH,                                                                                                    
                   F.INLINE_CT AS CT,                                                                                                               
                   F.INLINE_PROC_TIME AS PT,
                   ROW_NUMBER() OVER (PARTITION BY F.PROD_ID,F.PLAN_NO,F.PLAN_ID, F.OPE_NO ORDER BY F.TOOLG_ID DESC) AS SN                                                                                                         
            FROM {tempdb}APS_TMP_ETL_FLOW_REWORK_BACKUPEQP_RSDATA F                                                                                                                                                                                  
         )                                                                                                                                             
         SELECT FD.PROD_ID, FD.PLAN_NO, FD.PLAN_ID,                                                                                                    
              FD.STEP_ID,                                                                                                                              
              FD.LAYER,                                                                                                                                
              FD.STAGE,                                                                                                                                
              FD.TOOLG_ID, FD.RECIPE, FD.RETICLE_GROUP,                                                                                                
              FD.STEP_TYPE, FD.TOOLG_TYPE,                                                                                                             
              FD.OPE_NO, CASE WHEN LENGTH(FD.CAPABILITY) > 512 THEN SUBSTRING(FD.CAPABILITY,1,512) ELSE FD.CAPABILITY END AS CAPABILITY,                  
              FD.SGS_FLAG, FD.PRODG_ID, FD.PRODG_TECH,                                                                                                 
              COALESCE(ZWS.PROCESS_TIME,ZWST.PROCESS_TIME,ZWSO.PROCESS_TIME,ZWS2.PROCESS_TIME,0) AS PROCESS_TIME,                              
              COALESCE(ZWS.CYCLE_TIME,ZWST.CYCLE_TIME,ZWSO.CYCLE_TIME,ZWS2.CYCLE_TIME,0) AS CYCLE_TIME,                                    
              FD.SGS_GROUP                                                                                                                             
          FROM ALLFLOW_DATA FD                                                                                                                                                                                                                                      
              LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_TYPE11_MEDIAN ZWS                                                                                                
              ON ZWS.PROD_ID = FD.PROD_ID AND ZWS.OPE_NO = FD.OPE_NO AND ZWS.TOOLG_ID = FD.TOOLG_ID  
              LEFT JOIN APS_TMP_TYPE11_TECH_MEDIAN.APS_TMP_TYPE11_TECH_MEDIAN ZWST 
              ON ZWST.PROD_TECH = FD.PRODG_TECH AND ZWST.OPE_NO = FD.OPE_NO AND ZWST.TOOLG_ID = FD.TOOLG_ID 
              LEFT JOIN APS_TMP_TYPE12_OPE_MEDIAN.APS_TMP_TYPE12_OPE_MEDIAN ZWSO
              ON ZWSO.OPE_NO = FD.OPE_NO AND ZWSO.TOOLG_ID = FD.TOOLG_ID                                                       
              LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_TYPE12_MEDIAN ZWS2                                                                                                
              ON ZWS2.TOOLG_ID = FD.TOOLG_ID    
          WHERE FD.SN=1                                                                                                                                                                                                    
             """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW2",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW")


# 获取MainFlow的信息
def GetOtherMainFlowSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
            INSERT /*+ append */ INTO {tempdb}APS_TMP_ETL_FLOW_MAIN(                                                                                        
                 PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER, STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,
                 STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG, PRODG_ID, PRODG_TECH, PROCESS_TIME, CYCLE_TIME,
                 SGS_GROUP, OPE_SEQ                                                                                                                    
              )                                                                                                                                                             
               SELECT FD.PROD_ID, FD.PLAN_NO, FD.PLAN_ID,                                                                                                         
                    CASE WHEN LENGTH(FL.STEP_ID) > 10 THEN SUBSTR(FL.STEP_ID,-10) ELSE COALESCE(FL.STEP_ID,'') END AS STEP_ID,                                                                                                                
                    FD.LAYER,                                                                                                                                     
                    FD.STAGE,                                                                                                                                     
                    FD.TOOLG_ID, FD.RECIPE, FD.RETICLE_GROUP,                                                                                                     
                    FD.STEP_TYPE, FD.TOOLG_TYPE,                                                                                                                  
                    FD.OPE_NO, CASE WHEN LENGTH(FD.CAPABILITY) > 512 THEN SUBSTRING(FD.CAPABILITY,1,512) ELSE FD.CAPABILITY END AS CAPABILITY,                       
                    FD.SGS_FLAG, FD.PRODG_ID, FD.PRODG_TECH,                                                                                                      
                    COALESCE(ZWS.PROCESS_TIME,ZWST.PROCESS_TIME,ZWSO.PROCESS_TIME,ZWS2.PROCESS_TIME,0) AS PROCESS_TIME,                              
                    COALESCE(ZWS.CYCLE_TIME,ZWST.CYCLE_TIME,ZWSO.CYCLE_TIME,ZWS2.CYCLE_TIME,0) AS CYCLE_TIME,                                           
                    FD.SGS_GROUP,FD.STEP_ID                                                                                                                       
                    FROM {tempdb}APS_TMP_ETL_FLOW_MAIN_PROD_RSDATA FD                                                                                                  
                    LEFT JOIN LAST_APS_ETL_FLOW.APS_ETL_FLOW FL                                                                                                                     
                    ON FL.PROD_ID = FD.PROD_ID AND FL.PLAN_ID = FD.PLAN_ID AND FL.LAYER = FD.LAYER                                                               
                    AND FL.STAGE = FD.STAGE                                
                    LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_TYPE11_MEDIAN ZWS                                                                                                
                    ON ZWS.PROD_ID = FD.PROD_ID AND ZWS.OPE_NO = FD.OPE_NO AND ZWS.TOOLG_ID = FD.TOOLG_ID  
                    LEFT JOIN APS_TMP_TYPE11_TECH_MEDIAN.APS_TMP_TYPE11_TECH_MEDIAN ZWST 
                    ON ZWST.PROD_TECH = FD.PRODG_TECH AND ZWST.OPE_NO = FD.OPE_NO AND ZWST.TOOLG_ID = FD.TOOLG_ID 
                    LEFT JOIN APS_TMP_TYPE12_OPE_MEDIAN.APS_TMP_TYPE12_OPE_MEDIAN ZWSO
                    ON ZWSO.OPE_NO = FD.OPE_NO AND ZWSO.TOOLG_ID = FD.TOOLG_ID                                                       
                    LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_TYPE12_MEDIAN ZWS2                                                                                              
                    ON ZWS2.TOOLG_ID = FD.TOOLG_ID                                                                          
                   """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_MAIN",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_MAIN")

    # 获取RewFlow及SubFlow的信息


def GetOtherRwkToSubFlowSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
            INSERT /*+ append */ INTO {tempdb}APS_TMP_ETL_FLOW_RWK_SUB(                                                                               
                   PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER, STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,
                   STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG, PRODG_ID, PRODG_TECH, PROCESS_TIME, CYCLE_TIME,
                   SGS_GROUP, OPE_SEQ                                                                                                                                  
            )                                                                                                                                              
             WITH ALLFLOW_DATA AS (                                                                                                                             
             SELECT F.PROD_ID,                                                                                                                                                                                                                              
                       F.PLAN_NO,                                                                                                                                    
                       F.PLAN_ID,                                                                                                                                    
                       F.STEP_ID,                                                                                                                    
                       F.LAYER,                                                                                                                        
                       F.STAGE,                                                                                                                        
                       F.TOOLG_ID,                                                                                                                  
                       F.RECIPE,                                                                                                                      
                       F.RETICLE_GROUP,                                                                                                        
                       F.STEP_TYPE,                                                                                                                
                       F.TOOLG_TYPE,                                                                                                              
                       F.SGS_FLAG,                                                                                                                  
                       F.SGS_GROUP,                                                                                                                
                       F.OPE_NO,                                                                                                                                     
                       F.BACKUP_EQP AS CAPABILITY,                                                                                                              
                       F.PRODG_ID,                                                                                                                  
                       F.PRODG_TECH,                                                                                                              
                       F.INLINE_CT AS CT,                                                                                                                       
                       F.INLINE_PROC_TIME AS PT,                                                                                              
                       ROW_NUMBER() OVER (PARTITION BY F.PROD_ID,F.PLAN_NO,F.PLAN_ID, F.OPE_NO ORDER BY F.TOOLG_ID DESC) AS SN                                                                                                                 
                FROM {tempdb}APS_TMP_ETL_FLOW_REWORK_BACKUPEQP_RSDATA F                                                                                         
             )                                                                                                                                             
             SELECT FD.PROD_ID, FD.PLAN_NO, FD.PLAN_ID,                                                                                                    
                  CASE WHEN LENGTH(FL.STEP_ID) > 10 THEN SUBSTR(FL.STEP_ID,-10) ELSE COALESCE(FL.STEP_ID,'') END AS STEP_ID,                                                                                                          
                  FD.LAYER,                                                                                                                                
                  FD.STAGE,                                                                                                                                
                  FD.TOOLG_ID, FD.RECIPE, FD.RETICLE_GROUP,                                                                                                
                  FD.STEP_TYPE, FD.TOOLG_TYPE,                                                                                                             
                  FD.OPE_NO, CASE WHEN LENGTH(FD.CAPABILITY) > 512 THEN SUBSTRING(FD.CAPABILITY,1,512) ELSE FD.CAPABILITY END AS CAPABILITY,                  
                  FD.SGS_FLAG, FD.PRODG_ID, FD.PRODG_TECH,                                                                                                 
                  COALESCE(ZWS.PROCESS_TIME,ZWST.PROCESS_TIME,ZWSO.PROCESS_TIME,ZWS2.PROCESS_TIME,0) AS PROCESS_TIME,                              
                  COALESCE(ZWS.CYCLE_TIME,ZWST.CYCLE_TIME,ZWSO.CYCLE_TIME,ZWS2.CYCLE_TIME,0) AS CYCLE_TIME,                                    
                  FD.SGS_GROUP,FD.STEP_ID                                                                                                                  
              FROM ALLFLOW_DATA FD                                                                                                                          
                  LEFT JOIN LAST_APS_ETL_FLOW.APS_ETL_FLOW FL                                                                                                                          
                  ON FL.PROD_ID = FD.PROD_ID AND FL.PLAN_ID = FD.PLAN_ID AND FL.LAYER = FD.LAYER                                                                 
                  AND FL.STAGE = FD.STAGE                                     
                  LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_TYPE11_MEDIAN ZWS                                                                                                
                  ON ZWS.PROD_ID = FD.PROD_ID AND ZWS.OPE_NO = FD.OPE_NO AND ZWS.TOOLG_ID = FD.TOOLG_ID  
                  LEFT JOIN APS_TMP_TYPE11_TECH_MEDIAN.APS_TMP_TYPE11_TECH_MEDIAN ZWST 
                  ON ZWST.PROD_TECH = FD.PRODG_TECH AND ZWST.OPE_NO = FD.OPE_NO AND ZWST.TOOLG_ID = FD.TOOLG_ID 
                  LEFT JOIN APS_TMP_TYPE12_OPE_MEDIAN.APS_TMP_TYPE12_OPE_MEDIAN ZWSO
                  ON ZWSO.OPE_NO = FD.OPE_NO AND ZWSO.TOOLG_ID = FD.TOOLG_ID                                                       
                  LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_TYPE12_MEDIAN ZWS2                                                                                                
                  ON ZWS2.TOOLG_ID = FD.TOOLG_ID                                                                                                                 
                WHERE FD.SN=1                                                                                                                                   
        """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_RWK_SUB",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_RWK_SUB")


# 处理Seq顺序变化的问题
def GetChangeSeqData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
            INSERT /*+ append */ INTO {tempdb}APS_TMP_ETL_FLOW_CHANGESEQ(                
                    PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER, STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,
                    STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG, PRODG_ID, PRODG_TECH, PROCESS_TIME, CYCLE_TIME,
                    SGS_GROUP, OPE_SEQ                                                                         
                 )                                                                                  
                  WITH ALL_DATA AS (                                                                
                     SELECT * FROM {tempdb}APS_TMP_ETL_FLOW_MAIN                                
                     UNION ALL                                                                      
                     SELECT * FROM {tempdb}APS_TMP_ETL_FLOW_RWK_SUB                                 
                  )                                                                                 
                  SELECT PROD_ID, PLAN_NO, PLAN_ID,                                                 
                         CASE WHEN (STEP_ID IS NULL or STEP_ID = '' ) THEN NULL ELSE (                                 
                           CASE WHEN STEP_ID < MAX(STEP_ID) OVER(PARTITION BY PROD_ID, PLAN_ID      
                                          ORDER BY OPE_SEQ ROWS BETWEEN                             
                                                 UNBOUNDED PRECEDING AND CURRENT ROW)               
                             THEN NULL ELSE STEP_ID END                                             
                         )END AS STEP_ID,                                                           
                         LAYER, STAGE, TOOLG_ID,  RECIPE,                                           
                         RETICLE_GROUP, STEP_TYPE, TOOLG_TYPE, OPE_NO,                              
                         CAPABILITY, SGS_FLAG, PRODG_ID,                                            
                        PRODG_TECH, PROCESS_TIME,                                                   
                        CYCLE_TIME, SGS_GROUP, OPE_SEQ                                              
                  FROM ALL_DATA                                                                        
                  """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_CHANGESEQ",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_CHANGESEQ")


def GetAllChangeData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
                  INSERT /*+ append */ INTO {tempdb}APS_TMP_ETL_FLOW(                                                                         
                          PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER, STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,
                          STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG, PRODG_ID, PRODG_TECH, PROCESS_TIME,
                          CYCLE_TIME, SGS_GROUP                                                                                                                       
                  )                                                                                                                                      
           WITH ALL_DATA AS (                                                                                                                                                                                                   
                       SELECT PROD_ID, PLAN_NO, PLAN_ID,
                              COALESCE(STEP_ID,
                              	(
                              	       CASE WHEN 
                                			  (
                                			  	LAST_VALUE(SUBSTRING(STEP_ID,2,length(STEP_ID)) IGNORE NULLS)  OVER(PARTITION BY PROD_ID, PLAN_ID ORDER BY OPE_SEQ ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) = ''
                                			    OR 
                                			    LAST_VALUE(SUBSTRING(STEP_ID,2,length(STEP_ID)) IGNORE NULLS)  OVER(PARTITION BY PROD_ID, PLAN_ID ORDER BY OPE_SEQ ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) is NULL
                                			  ) 
                             	          	  AND
                             	          	  (
                             	          	  	FIRST_VALUE(SUBSTRING(STEP_ID,2,length(STEP_ID)) IGNORE NULLS )  OVER(PARTITION BY PROD_ID, PLAN_ID ORDER BY OPE_SEQ ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) = ''
                             	          	  	OR 
                             	          	  	FIRST_VALUE(SUBSTRING(STEP_ID,2,length(STEP_ID)) IGNORE NULLS )  OVER(PARTITION BY PROD_ID, PLAN_ID ORDER BY OPE_SEQ ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) IS NULL
                             	          	  )

                                     	THEN NULL
                             	     ELSE
                             	     	(CAST(LAST_VALUE(SUBSTRING(STEP_ID,2,length(STEP_ID)) IGNORE NULLS ) OVER(PARTITION BY PROD_ID, PLAN_ID ORDER BY OPE_SEQ ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS DECIMAL) +
                             	     	 CAST(FIRST_VALUE(SUBSTRING(STEP_ID,2,length(STEP_ID)) IGNORE NULLS )  OVER(PARTITION BY PROD_ID, PLAN_ID ORDER BY OPE_SEQ ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) AS DECIMAL)) /2
                             	     END
                              	)
                                 ) AS STEP_ID,                                                                                                          
                               LAYER, STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,                                                                           
                               STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG,                                                                      
                               PRODG_ID, PRODG_TECH, PROCESS_TIME, CYCLE_TIME, SGS_GROUP, OPE_SEQ,                                              
                                FIRST_VALUE(SUBSTRING(STEP_ID, 2, length(STEP_ID)) IGNORE NULLS )                                                            
                             OVER(PARTITION BY PROD_ID, PLAN_ID ORDER BY OPE_SEQ ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) AS LAST_STEP,        
                             LAST_VALUE(SUBSTRING(STEP_ID,2, length(STEP_ID) ) IGNORE NULLS )                                                               
                             OVER(PARTITION BY PROD_ID, PLAN_ID ORDER BY OPE_SEQ ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS FIRST_STEP         
                        FROM {tempdb}APS_TMP_ETL_FLOW_CHANGESEQ                                                                               
                    ),                                                                                                                                   
                    REPEAT_CHECK_DATA AS (SELECT PROD_ID, PLAN_NO, PLAN_ID,                                                                              
                               CASE  WHEN (STEP_ID IS NOT NULL AND STEP_ID <> '') 
                                        THEN STEP_ID 
                                     WHEN (LAST_STEP IS NULL OR LAST_STEP = '') AND (FIRST_STEP IS NULL OR FIRST_STEP = '') 
                                        THEN CASE WHEN LENGTH(OPE_SEQ)<10 THEN '.'||OPE_SEQ ELSE OPE_SEQ END
                                     WHEN (LAST_STEP IS NULL OR LAST_STEP = '') AND (FIRST_STEP IS NOT NULL AND FIRST_STEP <> '')
                                        THEN CONCAT(CAST((CAST(FIRST_STEP AS DECIMAL)+0.01) AS STRING),'A')
                                     ELSE 
                                        CONCAT(CAST((CAST(LAST_STEP AS DECIMAL)-0.01) AS STRING),'A')
                               END AS step_id,                                                                                        
                               LAYER, STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,                                                                           
                               STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG,                                                                      
                               PRODG_ID, PRODG_TECH, PROCESS_TIME, CYCLE_TIME, SGS_GROUP, OPE_SEQ,                                                                                         
                               LAST_STEP,FIRST_STEP                                                                                                      
                        FROM ALL_DATA                                                                                        
                    ),                                                                                                                                   
                    ROW_NUMBER_DATA AS (                                                                                                                 
                        SELECT PROD_ID, PLAN_NO, PLAN_ID,                                                                                                
                               STEP_ID,                                                                                                                  
                               LAYER, STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,                                                                           
                               STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG,                                                                      
                               PRODG_ID, PRODG_TECH, PROCESS_TIME, CYCLE_TIME, SGS_GROUP, OPE_SEQ,                                                       
                               COUNT(STEP_ID) OVER(PARTITION BY PROD_ID,PLAN_ID,STEP_ID) AS N_NUM,                                                       
                               LAST_STEP,FIRST_STEP                                                                                                      
                        FROM REPEAT_CHECK_DATA                                                                                                           
                    ),                                                                                                                                   
                    NULL_ROW_LESS AS (                                                                                                                   
                          SELECT PROD_ID, PLAN_NO, PLAN_ID,                                                                                                     
                                  CASE WHEN (LENGTH(STEP_ID)<10) THEN printf('.%09.4f',cast(STEP_ID as float)) ELSE STEP_ID END AS STEP_ID,
                               --CASE WHEN (LENGTH(STEP_ID)<10) THEN '.'||STEP_ID ELSE STEP_ID END AS STEP_ID,                    
                               LAYER, STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,                                                                           
                               STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG,                                                                      
                               PRODG_ID, PRODG_TECH, PROCESS_TIME, CYCLE_TIME, SGS_GROUP, OPE_SEQ                                                        
                          FROM  ROW_NUMBER_DATA                                                                                                          
                          WHERE N_NUM <= 1 AND NOT REGEXP_MATCHES(STEP_ID,'A')                                                                              
                    ),                                                                                                                                                                                                                                                                   
                    MIDDLE_ROW_THAN AS (                                                                                                                 
                         SELECT A.PROD_ID, A.PLAN_NO, A.PLAN_ID,                                                                                         
                               -- REPLACE(A.STEP_ID, 'A', '') AS STEP_ID, 
                            A.STEP_ID,                                                                                               
                               LAYER, STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,                                                                           
                               STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG,                                                                      
                               PRODG_ID, PRODG_TECH, PROCESS_TIME, CYCLE_TIME, SGS_GROUP, OPE_SEQ,                                                       
                               LAST_STEP,FIRST_STEP,                                                                                                     
                               ROW_NUMBER() OVER (PARTITION BY A.PROD_ID,A.PLAN_ID,A.STEP_ID ORDER BY OPE_SEQ) AS ROW_NUM,                               
                               ROW_NUMBER() OVER (PARTITION BY A.PROD_ID,A.PLAN_ID,A.STEP_ID ORDER BY OPE_SEQ DESC) AS ROW_NUM1,                         
                               A.N_NUM AS N_COUNT                                                                                                               
                          FROM  ROW_NUMBER_DATA  A                                                                                                                                                                                                         
                          WHERE N_NUM > 1 OR REGEXP_MATCHES(STEP_ID,'A')                                                                     
                    ),      
                    ROW_THEN_CHANGE AS (                                                                                                                 
                         SELECT PROD_ID, PLAN_NO, PLAN_ID,                                                                                               
                               CASE WHEN (FIRST_STEP IS NULL OR FIRST_STEP = '' AND (LAST_STEP IS NOT NULL AND LAST_STEP <> '')) 
                                            THEN 
                                            	-- '.'|| LPAD(CAST((cast(LAST_STEP as decimal) - (1/(cast(N_COUNT as decimal)+1)*cast(ROW_NUM1 as decimal))) AS DECIMAL(4, 0)),4,'0') || '.0000'  
                                            	printf('.%09.4f',cast((cast(LAST_STEP as decimal) - (1/(cast(N_COUNT as decimal)+1)*cast(ROW_NUM1 as decimal))) as float))
                                     WHEN (LAST_STEP IS NULL OR LAST_STEP = '' AND (FIRST_STEP IS NOT NULL AND FIRST_STEP <> '')) 
                                            THEN  
                                             -- '.'|| LPAD(CAST((cast(FIRST_STEP as decimal) + (1/(cast(N_COUNT as decimal)+1)*cast(ROW_NUM as decimal))) AS DECIMAL(4, 0)),4,'0') || '.0000'   
                                             printf('.%09.4f',cast((cast(FIRST_STEP as decimal) + (1/(cast(N_COUNT as decimal)+1)*cast(ROW_NUM as decimal))) as float))

                                    ELSE 
                                       -- ('.'|| LPAD(CAST( (CAST(FIRST_STEP as decimal) + ((cast(LAST_STEP as decimal) - cast(FIRST_STEP as decimal))/(cast(N_COUNT as decimal)+1)*cast(ROW_NUM as decimal)))  AS DECIMAL(4, 0)),4,'0') || '.0000'  )                                            
                                        printf('.%09.4f',cast((CAST(FIRST_STEP as decimal) + ((cast(LAST_STEP as decimal) - cast(FIRST_STEP as decimal))/(cast(N_COUNT as decimal)+1)*cast(ROW_NUM as decimal)))  as float))
                                        END AS STEP_ID,
                               LAYER, STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,                                                                           
                               STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG,                                                                 
                               PRODG_ID, PRODG_TECH, PROCESS_TIME, CYCLE_TIME, SGS_GROUP, OPE_SEQ                                                        
                          FROM  MIDDLE_ROW_THAN                                                                                                          
                    )                                                                                                                                    
                    SELECT PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER,                                                                                    
                           STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,                                                                                      
                           STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY,                                                                                    
                           SGS_FLAG, PRODG_ID, PRODG_TECH, PROCESS_TIME,                                                                                 
                           CYCLE_TIME, SGS_GROUP                                                                                                         
                     FROM ROW_THEN_CHANGE                                                                                                                
                     UNION ALL                                                                                                                           
                     SELECT PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER,                                                                                   
                           STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,                                                                                      
                           STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY,                                                                                    
                           SGS_FLAG, PRODG_ID, PRODG_TECH, PROCESS_TIME,                                                                                 
                           CYCLE_TIME, SGS_GROUP                                                                                                         
                    FROM NULL_ROW_LESS                                                                               
                  """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW")


# 查找SkipFlag的数据，因为某些量测站点是直接跳站的，没有必要算其cycleTime
def GetSkipFlagData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
         INSERT  /*+ append */ INTO {tempdb}APS_TMP_ETL_FLOW_SKIP_FLAG(
              PLAN_ID, OPE_NO
         )
          SELECT DISTINCT F.MAINPD_ID,F.OPE_NO
           FROM APS_SYNC_CSFLOWSAMPLINGCFG.APS_SYNC_CSFLOWSAMPLINGCFG F
            WHERE F.SAMPLING_GROUP1 = '0'      
            AND F.SAMPLING_TYPE='A'                                         
              """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_SKIP_FLAG",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_SKIP_FLAG")

# 需要把 V_FLOW_SUBFLOW_RETURN 中的Branch Flow 重编StepID
def GetAnnotationBranchFlowData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
         INSERT  /*+ append */ INTO {tempdb}APS_TMP_ETL_FLOW_ANNOTATION_BRANCH(
               PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER, STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP, 
               STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG, PRODG_ID, PRODG_TECH, PROCESS_TIME, 
               CYCLE_TIME, SGS_GROUP, MAIN_PLAN_ID, ENTRY_STEP_ID, RETN_STEP_ID
         )
         WITH T0 AS (                                                                                                                                                                                                                          
             SELECT * FROM {tempdb}APS_TMP_ETL_FLOW                                                                                                    
         ),                                                                                                                                                  
         T1 AS (                                                                                                                                             
            SELECT S.MAINPD_ID,                                                                                                                              
                   S.OPE_NO AS ENTN_OPE_NO,                                                                                                                  
                   S.BRANCH_MAINPD_ID,                                                                                                                       
                   S.RTN_OPE_NO AS RETN_OPE_NO,                                                                                                              
                   F1.STEP_ID AS ENTRY_STEP_ID,                                                                                                              
                   F2.STEP_ID AS RETN_STEP_ID,                                                                                                               
                   F1.PROD_ID                                                                                                                                
            FROM APS_SYNC_FLOW_SUBFLOW_RETURN.APS_SYNC_FLOW_SUBFLOW_RETURN S                                                                                                                          
            INNER JOIN {tempdb}APS_TMP_ETL_FLOW_VIEW_FLOW F ON F.MNPD_ID = S.MAINPD_ID                                                            
            INNER JOIN T0 F1 ON S.MAINPD_ID = F1.PLAN_ID AND S.OPE_NO = F1.OPE_NO                                                                            
            INNER JOIN T0 F2 ON S.MAINPD_ID = F2.PLAN_ID AND S.RTN_OPE_NO = F2.OPE_NO                                                                        
            AND F1.PROD_ID = F2.PROD_ID AND F1.PLAN_ID = F2.PLAN_ID                                                                                          
            WHERE INSTR(S.BRANCH_MAINPD_ID,'XX') = 0                                                                                                                                                                                             
         ),                                                                                                                                                  
         T2 AS (                                                                                                                                             
            SELECT ROW_NUMBER() OVER(PARTITION BY T1.PROD_ID,T1.BRANCH_MAINPD_ID ORDER BY T1.ENTRY_STEP_ID) AS RTN,                          
            T1.*                                                                                                                                             
            FROM T1                                                                                                                                          
         )                                                                                                                                   
          SELECT  DISTINCT T0.PROD_ID, T0.PLAN_NO, T0.PLAN_ID,                                                                                                   
                  COALESCE(T2.ENTRY_STEP_ID,'')||T0.STEP_ID AS STEP_ID,                                                                                   
                  T0.LAYER, T0.STAGE, T0.TOOLG_ID,                                                                                                        
                  T0.RECIPE, T0.RETICLE_GROUP,                                                                                                            
                  T0.STEP_TYPE, T0.TOOLG_TYPE, T0.OPE_NO,                                                                                                        
                  T0.CAPABILITY, T0.SGS_FLAG, T0.PRODG_ID,                                                                                                
                  T0.PRODG_TECH, T0.PROCESS_TIME,                                                                                                         
                  T0.CYCLE_TIME, T0.SGS_GROUP,                                                                                                                   
                  T2.MAINPD_ID AS MAIN_PLAN_ID,                                                                                              
                  T2.ENTRY_STEP_ID AS ENTRY_STEP_ID,                                                                                         
                  T2.RETN_STEP_ID AS RETN_STEP_ID                                                                                            
          FROM T0                                                                                                                                                
          LEFT JOIN T2                                                                                                                                            
          ON T2.RTN = 1                                                                                                                                            
          AND T2.PROD_ID = T0.PROD_ID                                                                                                                            
          AND T2.BRANCH_MAINPD_ID = T0.PLAN_ID                                         
              """.format(tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_TMP_ETL_FLOW_ANNOTATION_BRANCH",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_TMP_ETL_FLOW_ANNOTATION_BRANCH")


# 关联中位数信息并保存
def JoinMedianSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name):
    sql = """
           INSERT INTO APS_ETL_FLOW(
              PARENTID, PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, LAYER, STAGE, TOOLG_ID,  RECIPE, RETICLE_GROUP,
              STEP_TYPE, TOOLG_TYPE, OPE_NO, CAPABILITY, SGS_FLAG, PRODG_ID, PRODG_TECH, PROCESS_TIME,
              CYCLE_TIME, SGS_GROUP, MULTI_GROUP, MULTI_TARGET_FLAG,SKIP_FLAG, UPDATE_TIME, PARTCODE,
              MAIN_PLAN_ID,ENTRY_STEP_ID,RETN_STEP_ID)                                                
            SELECT '{uuid}' AS PARENTID,                                                   
            M.PROD_ID, CAST(M.PLAN_NO AS INTEGER), M.PLAN_ID, M.STEP_ID, M.LAYER, M.STAGE, M.TOOLG_ID,                      
            M.RECIPE, M.RETICLE_GROUP, M.STEP_TYPE, M.TOOLG_TYPE, M.OPE_NO, 
            CASE WHEN M.CAPABILITY ='' THEN NULL ELSE M.CAPABILITY END AS CAPABILITY,                  
            M.SGS_FLAG, M.PRODG_ID, M.PRODG_TECH, CAST(M.PROCESS_TIME AS DECIMAL), CAST(M.CYCLE_TIME AS DECIMAL), M.SGS_GROUP,               
            N.MULTI_GROUP, CAST(N.MULTI_TARGET_FLAG AS INTEGER),      
            CASE WHEN (F.OPE_NO IS NOT NULL AND F.OPE_NO <> '') THEN '1' END AS SKIP_FLAG,                                                    
            '{current_time}' AS UPDATE_TIME,                                                                                                           
            '' AS PARTCODE,
            M.MAIN_PLAN_ID, M.ENTRY_STEP_ID, M.RETN_STEP_ID                                                                                                
            FROM {tempdb}APS_TMP_ETL_FLOW_ANNOTATION_BRANCH M                                                                                                             
            LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_PO_N1 N                                                                                                             
            ON M.OPE_NO = N.OPE_NO AND M.PLAN_ID = N.MAINPD_ID AND (N.MULTI_GROUP IS NOT NULL AND N.MULTI_GROUP <> '' )   
            LEFT JOIN {tempdb}APS_TMP_ETL_FLOW_SKIP_FLAG F   
            ON M.OPE_NO = F.OPE_NO AND M.PLAN_ID = F.PLAN_ID                                                                                                   
                """.format(uuid=uuid, current_time=current_time, tempdb=my_duck.get_temp_table_mark())

    my_duck.exec_sql(oracle_conn=oracle_conn,
                     duck_db_memory=duck_db_memory,
                     ETL_Proc_Name=ETL_Proc_Name,
                     methodName="Insert Into APS_ETL_FLOW",
                     sql=sql,
                     current_time=current_time,
                     update_table="APS_ETL_FLOW")


def execute():
    from xinxiang.util import my_runner
    if not my_runner.judge_main_server():
        return

    ###############################################################
    ### 以下参数必须定义
    ### ETL_Proc_Name    : ETL 名称
    ### current_time     ：请直接拷贝
    ### current_time_short ：请直接拷贝
    ### uuid             ：请直接拷贝
    ### target_table     : 该ETL输出表名
    ### used_table_list  : 该ETL使用到的，参考到的表名(中间表不算)
    ### target_table_sql ： 该ETL输出表定义SQL
    ###############################################################
    ETL_Proc_Name = "APS_ETL_BR.APS_ETL_FLOW_720M"
    current_time = my_date.date_time_second_str()
    current_time_short = my_date.date_time_second_short_str()
    uuid = my_oracle.UUID()

    target_table = "APS_ETL_FLOW"
    used_table_list = ['APS_SYNC_FLOW',
                       'APS_SYNC_PF_PO_N1',
                       'APS_SYNC_PD_RECIPE_EQP_MAIN',
                       'APS_SYNC_ETL_TOOL',
                       'APS_TMP_TYPE11_MEDIAN',
                       'APS_TMP_TYPE11_TECH_MEDIAN',
                       'APS_TMP_TYPE12_OPE_MEDIAN',
                       'APS_TMP_TYPE12_MEDIAN',
                       'APS_SYNC_MASK_GROUP_MAPPLING',
                       'APS_SYNC_PRODUCT',
                       'APS_SYNC_CSFLOWSAMPLINGCFG',
                       'APS_SYNC_FLOW_SUBFLOW_RETURN'
                       ]
    target_table_sql = """
        create table {}APS_ETL_FLOW
        (
            parentid          VARCHAR(64) not null,
            prod_id           VARCHAR(64) not null,
            plan_no           INTEGER not null,
            plan_id           VARCHAR(64) not null,
            step_id           VARCHAR(64) not null,
            layer             VARCHAR(64),
            stage             VARCHAR(64),
            toolg_id          VARCHAR(64) not null,
            recipe            VARCHAR(64),
            reticle_group     VARCHAR(64),
            step_type         VARCHAR(1),
            toolg_type        VARCHAR(1),
            process_time      DECIMAL not null,
            cycle_time        DECIMAL not null,
            update_time       VARCHAR(64) not null,
            ope_no            VARCHAR(64),
            capability        VARCHAR(512),
            sgs_flag          VARCHAR(2),
            prodg_id          VARCHAR(64),
            prodg_tech        VARCHAR(64),
            partcode          VARCHAR(64) not null,
            sgs_group         VARCHAR(64),
            batch_name        VARCHAR(64),
            batch_target_flag VARCHAR(64),
            multi_group       VARCHAR(64),
            multi_target_flag INTEGER,
            SKIP_FLAG         VARCHAR(64),
            main_plan_id      VARCHAR(64),
            entry_step_id     VARCHAR(64),
            retn_step_id      VARCHAR(64),
            PRIMARY KEY (PARENTID, PROD_ID, PLAN_NO, PLAN_ID, STEP_ID, PARTCODE)
        )
    """.format("")  # 注意:这里一定要这么写 [create table 表名] => [create table {}表名]
    target_db_file = my_duck.get_target_file_name(target_table, current_time_short)

    # -------------------------- 内存模式改成文件模式
    _temp_db_path = os.path.join(config.g_mem_speed_etl_output_path, target_table, "inprocess")
    if not os.path.exists(_temp_db_path):
        os.makedirs(_temp_db_path)

    temp_db_file = os.path.join(_temp_db_path, target_table + "_" + current_time_short + "_temp.db")
    # 处理中文件
    in_process_db_file = os.path.join(_temp_db_path, target_table + "_" + current_time_short + ".db")
    # 结果文件
    target_db_file = os.path.join(config.g_mem_etl_output_path, target_table, target_table + "_" + current_time_short + ".db")
    # --------------------------

    oracle_conn = None
    try:

        _ssss = datetime.now()
        oracle_conn = my_oracle.oracle_get_connection()
        # 开始日志
        my_oracle.StartCleanUpAndLog(oracle_conn, ETL_Proc_Name, current_time)
        # -------------------------- 内存模式改成文件模式
        # 创建DuckDB
        duck_db_memory = my_duck.create_duckdb_in_file(_temp_db_path, in_process_db_file, target_table_sql)
        duck_db_memory.sql('SET threads TO 4')
        if not os.path.exists(os.path.join(config.g_mem_speed_etl_output_path, 'duck_temp', uuid)):
            os.makedirs(os.path.join(config.g_mem_speed_etl_output_path, 'duck_temp', uuid))
        duck_db_memory.execute("SET temp_directory='{}'".format(os.path.join(config.g_mem_speed_etl_output_path, 'duck_temp', uuid)))

        if not config.g_debug_mode:
            create_temp_table(duck_db_memory)
        else:
            duck_db_temp = my_duck.create_duckdb_for_temp_table(_temp_db_path, temp_db_file)
            # 创建Temp表
            create_temp_table(duck_db_temp)
            duck_db_temp.commit()
            duck_db_temp.close()
            my_duck.attach_temp_db_write_able(duck_db_memory, "TEMPDB", temp_db_file)
        # --------------------------

        # Attach用到的表
        res_dict = my_duck.attach_used_table(oracle_conn, duck_db_memory, used_table_list)
        ################################################################################################################
        ## 以下为业务逻辑
        ################################################################################################################
        # 获取APS_TMP_TYPE11_MEDIAN
        GetType11MedianDataSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 获取APS_TMP_TYPE12_MEDIAN
        GetType12MedianDataSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 先保存V_ETL_FLOW数据
        GetViewFlowSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 先把V_PF_PO_N1保存
        GetPoN1Sql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 先把V_PF_PO_N1保存(针对Dummy/Recycle/Equipment Monitor)
        GetRecyclePoN1Sql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 先把V_PD_RECIPE_EQP_MAIN / V_PD_RECIPE_EQP_REWORK保存
        GetRecipeEqpLoadSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # backUpEqp先获取出来
        GetFlowByBackUpEqpSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 获取RWK和SUB Flow出来
        GetSubAndRewFlowSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 获取(针对Dummy/Recycle/Equipment Monitor) Flow出来
        GetRecycleFlowSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 获取SUB/REWORK的备援机台信息
        GetSubAndRewFlowBackUpEqpSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 获取RECIPE出来
        GetFlowByRecipeSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 获取V_MASK_GROUP_MAPPLING信息
        GetMaskGroupMapSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 获取V_PRODUCT的信息
        GetProductSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 获取TOOL分组信息
        GetToolGroupSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 获取FLow的备援机群主信息
        getMainFlowRSData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 把主Flow的数据两两拆开
        # ①Mask_Group串接
        getMainFlowRSByMaskData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # ①Tool_Group串接
        getMainFlowRSByToolData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        #  ①Prod_Data串接
        getMainFlowRSByProdData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)

        # 把Rework串接Flow的部分拆开
        getRewDataByFlow(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 把Rework串接Flow的部分拆开
        getRewBackUpEqpData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 判断是否是第一次插入数据，因为要出来Step_ID
        # 取上一次的ETL_FLOW版本
        file_name = my_file.get_last_db_file(conn=oracle_conn, table_name="APS_ETL_FLOW")
        # if 取不到
        if file_name is None:
            # 获取MainFlow的信息
            GetFirstMainFlowSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
            # 获取RewFlow及SubFlow的信息
            GetFirstRwkToSubFlowSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # else 取到的情况下
        # 手动 Attach APS_ETL_FLOW AS LAST_APS_ETL_FLOW
        # 后面的Join均为 LAST_APS_ETL_FLOW.APS_ETL_FLOW
        # 将Java版本SQL反应进来
        else:
            print("---------------------------------------------------------------------------")
            print("APS_ETL_FLOW", file_name)
            print("---------------------------------------------------------------------------")
            my_duck.attach_table(duck_db_memory=duck_db_memory, table_name="LAST_APS_ETL_FLOW",
                                 target_db_file=file_name)
            # 获取MainFlow的信息
            GetOtherMainFlowSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
            # 获取RewFlow及SubFlow的信息
            GetOtherRwkToSubFlowSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
            # 处理Seq顺序变化的问题
            GetChangeSeqData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)

            GetAllChangeData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
            my_duck.detach_table(duck_db=duck_db_memory, db_name="LAST_APS_ETL_FLOW")

        #  查找SkipFlag的数据，因为某些量测站点是直接跳站的，没有必要算其cycleTime
        GetSkipFlagData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 记录注记站点资讯（主要是BranchFlow）
        GetAnnotationBranchFlowData(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        # 关联中位数信息并保存
        JoinMedianSql(duck_db_memory, uuid, current_time, oracle_conn, ETL_Proc_Name)
        _eeeee = datetime.now()
        print("Process:", my_date.duration(_ssss, _eeeee), 'Seconds')
        ################################################################################################################
        ## 以上为业务逻辑
        ################################################################################################################

        # Add Detach all used table
        my_duck.detach_all_used_table(duck_db_memory, res_dict)

        if config.g_copy_to_pg and my_runner.judge_main_server(oracle_conn):
            select_sql_in_duck = """select  parentid, prodg_id, prodg_tech,prod_id,plan_no,plan_id, step_id,layer,stage,toolg_id,recipe,reticle_group,step_type,toolg_type,process_time,
                                            cycle_time,capability,sgs_flag,update_time,sgs_group,batch_name, batch_target_flag,multi_group,multi_target_flag, SKIP_FLAG,main_plan_id,entry_step_id,retn_step_id  from APS_ETL_FLOW
                                        """
            postgres_table_define = """etl_flow(parentid, prodg_id, prodg_tech,prod_id,plan_no,plan_id, step_id,layer,stage,toolg_id,recipe,reticle_group,step_type,toolg_type,process_time,
                                                cycle_time,capability,sgs_flag,update_time,sgs_group,batch_name, batch_target_flag,multi_group,multi_target_flag, SKIP_FLAG,main_plan_id,entry_step_id,retn_step_id)
                                    """
            my_oracle.StartCleanUpAndLog(oracle_conn, ETL_Proc_Name, current_time)
            my_postgres.copy_duckdb_to_postgres(uuid=uuid,
                                                duckdb=duck_db_memory,
                                                table_name_in_duckdb=target_table,
                                                table_name_in_pg="etl_flow",  # 要小写
                                                select_sql_in_duck=select_sql_in_duck,
                                                postgres_table_define=postgres_table_define,
                                                oracle_conn=oracle_conn,
                                                ETL_Proc_Name=ETL_Proc_Name)
        _ssss = datetime.now()
        # -------------------------- 内存模式改成文件模式
        # 导出到目标文件中
        target_db_file = my_duck.export_result_duck_file_and_close_duck_db_memory2(duck_db_memory, in_process_db_file=in_process_db_file, target_table=target_table, current_time=current_time_short)
        # -------------------------
        # 写版本号
        my_oracle.HandlingVerControl(oracle_conn, uuid, target_table, target_db_file, current_time_short)
        # 写完成日志
        my_oracle.EndCleanUpAndLog(oracle_conn, ETL_Proc_Name, current_time)
        _eeeee = datetime.now()
        print("Save File Total:", my_date.duration(_ssss, _eeeee), 'Seconds')
    except Exception as e:
        # 写警告日志
        my_oracle.SaveAlarmLogData(oracle_conn, ETL_Proc_Name, e, target_db_file,
                                   cons_error_code.APS_ETL_FLOW_CODE_XX_ETL)
        logging.exception("{ETL_Proc_Name} 處理出錯 : {e}".format(ETL_Proc_Name=ETL_Proc_Name, e=e))
        # 导出到目标文件中
        my_duck.export_result_duck_file_and_close_duck_db_memory2(duck_db_memory,
                                                                  in_process_db_file=in_process_db_file,
                                                                  target_table=target_table,
                                                                  current_time=current_time_short)
        raise e
    finally:
        oracle_conn.commit()
        oracle_conn.close()
        # 删除TMP目录:LQN:2023/08/21
        if os.path.exists(os.path.join(config.g_mem_etl_output_path, 'duck_temp', uuid)):
            os.remove(os.path.join(config.g_mem_etl_output_path, 'duck_temp', uuid))
        if os.path.exists(temp_db_file) and not config.g_debug_mode:
            os.remove(temp_db_file)
        gc.collect()  # 内存释放


if __name__ == '__main__':
    # 单JOB测试用
    print("start")
    execute()
