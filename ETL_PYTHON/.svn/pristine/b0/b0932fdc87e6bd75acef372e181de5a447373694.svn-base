import gc
import logging
import os
import shutil
from datetime import datetime, timedelta, time

import duckdb

from xinxiang import config
from xinxiang.util import my_oracle, my_date, cons_error_code, oracle_to_duck_common
import pandas as pd
import numpy as np

from xinxiang.util.oracle_to_duck_his import delete_over_three_version


def execute():
    ###############################################################
    ### 以下参数必须定义
    ### ETL_Proc_Name    : ETL 名称
    ### current_time     ：请直接拷贝
    ### current_time_short ：请直接拷贝
    ### uuid             ：请直接拷贝
    ### target_table     : 该ETL输出表名
    ### used_table_list  : 该ETL使用到的，参考到的表名(中间表不算)
    ### target_table_sql ： 该ETL输出表定义SQL
    ###############################################################
    ETL_Proc_Name = "APS_ETL_BR.SYNC.APS_MID_FHOPEHS"
    current_time = my_date.date_time_second_str()
    current_time_short = my_date.date_time_second_short_str()
    uuid = my_oracle.UUID()

    source_table = "V_FHOPEHS"
    target_table_name = "APS_MID_FHOPEHS_VIEW"
    check_date_column = "CLAIM_TIME"
    sync_day = 40
    query_sql = """SELECT LOT_ID, LOT_TYPE, SUB_LOT_TYPE, CAST_ID, CAST_CATEGORY, MAINPD_ID, OPE_NO, PD_ID, OPE_PASS_COUNT, PD_NAME, HOLD_STATE, CLAIM_TIME, CLAIM_SHOP_DATE, CLAIM_USER_ID, MOVE_TYPE, OPE_CATEGORY, PROD_TYPE, TEST_TYPE, MFG_LAYER, EXT_PRIORITY, PRIORITY_CLASS, PREV_PRODSPEC_ID, PRODSPEC_ID, PRODGRP_ID, TECH_ID, CUSTOMER_ID, CUSTPROD_ID, ORDER_NO, STAGE_ID, STAGEGRP_ID, PHOTO_LAYER, LOCATION_ID, AREA_ID, EQP_ID, REPLACE(REPLACE(EQP_NAME, chr(10), ''), chr(13), '')  AS EQP_NAME, OPE_MODE, LC_RECIPE_ID, RECIPE_ID, PH_RECIPE_ID, RETICLE_COUNT, FIXTURE_COUNT, RPARM_COUNT, INIT_HOLD_FLAG, LAST_HLDREL_FLAG, HOLD_TIME, HOLD_SHOP_DATE, HOLD_USER_ID, HOLD_TYPE, HOLD_REASON_CODE, HOLD_REASON_DESC, REASON_CODE, REASON_DESCRIPTION, BANK_ID, PREV_BANK_ID, PREV_MAINPD_ID, PREV_OPE_NO, PREV_PD_ID, PREV_PD_NAME, PREV_PASS_COUNT, PREV_STAGE_ID, PREV_STAGEGRP_ID, PREV_PHOTO_LAYER, FLOWBATCH_ID, CTRL_JOB, REWORK_COUNT, ORG_WAFER_QTY, CUR_WAFER_QTY, PROD_WAFER_QTY, CNTL_WAFER_QTY, CLAIM_PROD_QTY, CLAIM_CNTL_QTY, TOTAL_GOOD_UNIT, TOTAL_FAIL_UNIT, LOT_OWNER_ID, PLAN_END_TIME, WFRHS_TIME, CRITERIA_FLAG, REPLACE(REPLACE(CLAIM_MEMO, chr(10), ''), chr(13), '')  AS CLAIM_MEMO, STORE_TIME, ORIG_LOT_ID, GET_FROM, FAB_ID, EVENT_CREATE_TIME, HOLD_OPE_NO, HOLD_REASON_OPE_NO, ORIGINAL_FAB_ID, DESTINATION_FAB_ID, RELATED_LOT_ID, BOND_GRP_ID, EQPMONJOB_ID, PD_TYPE, PREV_PD_TYPE FROM V_FHOPEHS"""
    create_table_sql = """
                CREATE TABLE APS_MID_FHOPEHS_VIEW (
                    LOT_ID VARCHAR,
                    LOT_TYPE VARCHAR,
                    SUB_LOT_TYPE VARCHAR,
                    CAST_ID VARCHAR,
                    CAST_CATEGORY VARCHAR,
                    MAINPD_ID VARCHAR,
                    OPE_NO VARCHAR,
                    PD_ID VARCHAR,
                    OPE_PASS_COUNT INTEGER,
                    PD_NAME VARCHAR,
                    HOLD_STATE VARCHAR,
                    CLAIM_TIME TIMESTAMP,
                    CLAIM_SHOP_DATE FLOAT,
                    CLAIM_USER_ID VARCHAR,
                    MOVE_TYPE VARCHAR,
                    OPE_CATEGORY VARCHAR,
                    PROD_TYPE VARCHAR,
                    TEST_TYPE VARCHAR,
                    MFG_LAYER VARCHAR,
                    EXT_PRIORITY INTEGER,
                    PRIORITY_CLASS INTEGER,
                    PREV_PRODSPEC_ID VARCHAR,
                    PRODSPEC_ID VARCHAR,
                    PRODGRP_ID VARCHAR,
                    TECH_ID VARCHAR,
                    CUSTOMER_ID VARCHAR,
                    CUSTPROD_ID VARCHAR,
                    ORDER_NO VARCHAR,
                    STAGE_ID VARCHAR,
                    STAGEGRP_ID VARCHAR,
                    PHOTO_LAYER VARCHAR,
                    LOCATION_ID VARCHAR,
                    AREA_ID VARCHAR,
                    EQP_ID VARCHAR,
                    EQP_NAME VARCHAR,
                    OPE_MODE VARCHAR,
                    LC_RECIPE_ID VARCHAR,
                    RECIPE_ID VARCHAR,
                    PH_RECIPE_ID VARCHAR,
                    RETICLE_COUNT INTEGER,
                    FIXTURE_COUNT INTEGER,
                    RPARM_COUNT INTEGER,
                    INIT_HOLD_FLAG INTEGER,
                    LAST_HLDREL_FLAG INTEGER,
                    HOLD_TIME TIMESTAMP,
                    HOLD_SHOP_DATE FLOAT,
                    HOLD_USER_ID VARCHAR,
                    HOLD_TYPE VARCHAR,
                    HOLD_REASON_CODE VARCHAR,
                    HOLD_REASON_DESC VARCHAR,
                    REASON_CODE VARCHAR,
                    REASON_DESCRIPTION VARCHAR,
                    BANK_ID VARCHAR,
                    PREV_BANK_ID VARCHAR,
                    PREV_MAINPD_ID VARCHAR,
                    PREV_OPE_NO VARCHAR,
                    PREV_PD_ID VARCHAR,
                    PREV_PD_NAME VARCHAR,
                    PREV_PASS_COUNT FLOAT,
                    PREV_STAGE_ID VARCHAR,
                    PREV_STAGEGRP_ID VARCHAR,
                    PREV_PHOTO_LAYER VARCHAR,
                    FLOWBATCH_ID VARCHAR,
                    CTRL_JOB VARCHAR,
                    REWORK_COUNT INTEGER,
                    ORG_WAFER_QTY INTEGER,
                    CUR_WAFER_QTY INTEGER,
                    PROD_WAFER_QTY INTEGER,
                    CNTL_WAFER_QTY INTEGER,
                    CLAIM_PROD_QTY INTEGER,
                    CLAIM_CNTL_QTY INTEGER,
                    TOTAL_GOOD_UNIT INTEGER,
                    TOTAL_FAIL_UNIT INTEGER,
                    LOT_OWNER_ID VARCHAR,
                    PLAN_END_TIME TIMESTAMP,
                    WFRHS_TIME TIMESTAMP,
                    CRITERIA_FLAG INTEGER,
                    CLAIM_MEMO VARCHAR,
                    STORE_TIME TIMESTAMP,
                    ORIG_LOT_ID VARCHAR,
                    GET_FROM VARCHAR,
                    FAB_ID VARCHAR,
                    EVENT_CREATE_TIME TIMESTAMP,
                    HOLD_OPE_NO VARCHAR,
                    HOLD_REASON_OPE_NO VARCHAR,
                    ORIGINAL_FAB_ID VARCHAR,
                    DESTINATION_FAB_ID VARCHAR,
                    RELATED_LOT_ID VARCHAR,
                    BOND_GRP_ID VARCHAR,
                    EQPMONJOB_ID VARCHAR,
                    PD_TYPE VARCHAR,
                    PREV_PD_TYPE VARCHAR
                );
                """

    oracle_conn = None
    try:
        oracle_conn = my_oracle.oracle_get_connection()

        _now = my_date.date_time_second_str()
        _now_short = my_date.date_time_second_short_str()

        target_path = config.g_mem_sync_result_path

        # 创建目录
        target_folder = os.path.join(target_path, target_table_name, "inprocess")
        if not os.path.exists(target_folder):
            os.makedirs(target_folder)

        # 创建DuckDB的文件
        _file_name = target_table_name + "_" + my_date.date_time_second_short_str() + ".db"
        _file_name_csv = target_table_name + "_" + my_date.date_time_second_short_str() + ".csv"
        in_process_db_file = os.path.join(target_folder, _file_name)
        target_db_file = os.path.join(target_path, target_table_name, _file_name)  # 最终文件在inprocess目录上层

        # 创建DuckDB文件
        duck_db_cursor = None
        # 记录开始日志
        my_oracle.StartCleanUpAndLog(conn=oracle_conn, ETLProcName=ETL_Proc_Name, ETLStartTime=_now)

        # 把历史数据先ATTACH过来，再拷贝到新的库中去
        last_file_name = my_oracle.get_last_create_file(my_oracle.oracle_get_connection(), target_table_name)
        print(last_file_name)
        if last_file_name:
            shutil.copy2(last_file_name, in_process_db_file)
            duck_db_cursor = duckdb.connect(in_process_db_file)
            # 追加最新的数据
            # 上次执行文件的创建时间戳
            sql = """SELECT MAX({check_date_column}) FROM {target_table}""".format(check_date_column="CLAIM_TIME",
                                                                                   target_table=target_table_name)
            duck_db_cursor.execute(sql)
            last_date = duck_db_cursor.fetchall()

            _create_time_date = last_date[0][0]
            if _create_time_date is not None:
                if type(_create_time_date) is str:
                    _create_time = datetime.strptime(_create_time_date, '%Y-%m-%d %H:%M:%S')
                else:
                    _create_time = _create_time_date
                _create_time = _create_time - timedelta(hours=2) # 提前兩個小時
                print(_create_time)

                query_sql = query_sql \
                            + " where 1=1 and {check_date_column} >= TO_DATE('{create_time}', 'YYYY-MM-DD HH24:MI:SS')" \
                                .format(check_date_column=check_date_column,
                                        create_time=_create_time)
                lask_one_hour_date = pd.read_sql(query_sql, oracle_conn)
                lask_one_hour_date = lask_one_hour_date.replace(pd.NaT, np.nan)
                lask_one_hour_date = lask_one_hour_date.replace(np.nan, '')

                query_duck_sql = """
                    select * from {target_table} where 1=1 and {check_date_column} >= DATE_TRUNC('second', CURRENT_TIMESTAMP) - INTERVAL '2 day'
                """.format(target_table=target_table_name,
                           check_date_column=check_date_column
                           )
                lask_one_hour_date_duck = pd.read_sql(query_duck_sql, duck_db_cursor)
                lask_one_hour_date_duck = lask_one_hour_date_duck.replace(pd.NaT, np.nan)
                lask_one_hour_date_duck = lask_one_hour_date_duck.replace(np.nan, '')

                columns_str = ", ".join(lask_one_hour_date.columns)
                placeholders = ", ".join(['?'] * len(lask_one_hour_date.columns))

                select_insert_item = """
                    insert into {target_table_name} ({columns_str})
                    select {columns_str}  FROM lask_one_hour_date HL
                    where 1=1
                    and  NOT EXISTS (
                        SELECT 1 FROM lask_one_hour_date_duck H
                        where 1=1
                        AND HL.LOT_ID = H.LOT_ID 
                        AND CAST(HL.CLAIM_TIME AS TIMESTAMP) = CAST(H.CLAIM_TIME AS TIMESTAMP)
                        AND CASE WHEN HL.OPE_NO IS NULL OR HL.OPE_NO = '' THEN '*' ELSE HL.OPE_NO END = CASE WHEN H.OPE_NO IS NULL OR H.OPE_NO = '' THEN '*' ELSE H.OPE_NO END
                        AND CASE WHEN HL.HOLD_REASON_CODE IS NULL OR HL.HOLD_REASON_CODE ='' THEN '*' ELSE HL.HOLD_REASON_CODE END  = CASE WHEN H.HOLD_REASON_CODE IS NULL OR H.HOLD_REASON_CODE ='' THEN '*' ELSE H.HOLD_REASON_CODE END
                        AND CASE WHEN HL.HOLD_TIME IS NULL OR HL.HOLD_TIME ='' THEN CAST('1901-01-01 00:00:00' AS TIMESTAMP) ELSE CAST(HL.HOLD_TIME AS TIMESTAMP) END = CASE WHEN H.HOLD_TIME IS NULL OR H.HOLD_TIME ='' THEN CAST('1901-01-01 00:00:00' AS TIMESTAMP) ELSE CAST(H.HOLD_TIME AS TIMESTAMP) END
                        AND CASE WHEN HL.MOVE_TYPE IS NULL OR HL.MOVE_TYPE ='' THEN '*' ELSE HL.MOVE_TYPE END = CASE WHEN H.MOVE_TYPE IS NULL OR H.MOVE_TYPE ='' THEN '*' ELSE H.MOVE_TYPE END        
                        AND CASE WHEN HL.INIT_HOLD_FLAG IS NULL  THEN CAST(-1 AS INTEGER) ELSE CAST(HL.INIT_HOLD_FLAG AS INTEGER) END = CASE WHEN H.INIT_HOLD_FLAG IS NULL  THEN CAST(-1 AS INTEGER) ELSE CAST(H.INIT_HOLD_FLAG AS INTEGER) END
                        AND CASE WHEN HL.OPE_CATEGORY IS NULL OR HL.OPE_CATEGORY ='' THEN '*' ELSE HL.OPE_CATEGORY END = CASE WHEN H.OPE_CATEGORY IS NULL OR H.OPE_CATEGORY ='' THEN '*' ELSE H.OPE_CATEGORY END
                        AND CASE WHEN HL.CLAIM_USER_ID IS NULL OR HL.CLAIM_USER_ID ='' THEN '*' ELSE HL.CLAIM_USER_ID END = CASE WHEN H.CLAIM_USER_ID IS NULL OR H.CLAIM_USER_ID ='' THEN '*' ELSE H.CLAIM_USER_ID END
                    )
                """.format(target_table_name=target_table_name, columns_str=columns_str, placeholders=placeholders)
                duck_db_cursor.execute(select_insert_item)

                # 删除老数据
                delete_sql = """
                       delete from {target_table} where {check_date_column} < DATE_TRUNC('second', CURRENT_TIMESTAMP) - INTERVAL '60 day'
                       """.format(target_table=target_table_name,
                                  check_date_column=check_date_column,
                                  save_day=sync_day + 1)
                duck_db_cursor.execute(delete_sql)
                duck_db_cursor.close()
                try:
                    os.rename(in_process_db_file, target_db_file)
                except Exception as eee:
                    logging.exception("文件太大，等待20秒后再拷贝... %s", eee)
                    time.sleep(20)
                    os.rename(in_process_db_file, target_db_file)

                # 写版本号
                my_oracle.HandlingVerControl(oracle_conn, uuid, target_table_name, target_db_file, current_time_short)
                # 写完成日志
                my_oracle.EndCleanUpAndLog(oracle_conn, ETL_Proc_Name, current_time)
        else:
            # 做全量
            query_sql = query_sql + """ where 1=1 and {check_date_column} >= SYSDATE - {sync_day}""".format(
                source_table=source_table,
                check_date_column=check_date_column,
                sync_day=sync_day)
            print(query_sql)
            oracle_to_duck_common.oracle_to_duck_csv(
                conn=oracle_conn,
                etl_name=ETL_Proc_Name,
                source_table=source_table,
                target_table=target_table_name,
                query_sql=query_sql,
                create_table_sql=create_table_sql
            )
    except Exception as e:
        # 写警告日志
        my_oracle.SaveAlarmLogData(oracle_conn, ETL_Proc_Name, e, target_db_file, "XETL072")
        logging.exception("{ETL_Proc_Name} 處理出錯 : {e}".format(ETL_Proc_Name=ETL_Proc_Name, e=e))

        raise e
    finally:
        delete_over_three_version(table_name=target_table_name)
        oracle_conn.commit()
        oracle_conn.close()
        # 删除TMP目录:LQN:2023/08/21
        if os.path.exists(os.path.join(config.g_mem_etl_output_path, 'duck_temp', uuid)):
            os.remove(os.path.join(config.g_mem_etl_output_path, 'duck_temp', uuid))
        gc.collect()  # 内存释放


if __name__ == '__main__':
    # 单JOB测试用
    print("start")
    execute()